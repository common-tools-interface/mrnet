<chapter id="mrnet_api"><title>The MRNet C++ API Reference</title>

<para>
All classes are included in the <varname>MRN</varname> namespace.
For this discussion, we do not explicitly include reference to the
namespace; for example, when we reference the class <classname>Network</classname>, we are
implying the class <classname>MRN::Network</classname>.
</para>

<para>
In MRNet, there are five top-level classes: <classname>Network</classname>,
<classname>NetworkTopology</classname>, <classname>Communicator</classname>,
<classname>Stream</classname>, and <classname>Packet</classname>.
The Network class primarily contains methods for instantiating and destroying MRNet
process trees. The NetworkTopology class represents
the interface for discovering details about the topology of an instantiated Network.
Application back-ends are referred to as end-points, and the Communicator
class is used to reference a group of end-points. A Communicator is used to 
establish a Stream for unicast, multicast, or broadcast communications 
via the MRNet infrastructure. The Packet class encapsulates the data packets 
that are sent on a Stream. The public members of these classes are detailed below.
</para>

<sect1 id="sect:network_api"> <title>Class Network</title>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>Network::Network</function></funcdef>
    <paramdef>const char * <parameter>topology</parameter></paramdef>
    <paramdef>const char * <parameter>backend_exe</parameter></paramdef>
    <paramdef>const char ** <parameter>backend_argv</parameter></paramdef>
    <paramdef>bool <parameter>rank_backends</parameter> =true</paramdef>
    <paramdef>bool <parameter>using_memory_buffer</parameter> =false</paramdef>
</funcprototype>
<blockquote>
<para>
The front-end constructor method that is used
to instantiate the MRNet process tree. <varname>topology</varname> is
the path to a configuration file that describes the desired process tree
topology. 
</para>
<para>
<varname>backend_exe</varname> is the path to the executable to be
used for the application's back-end processes. <varname>backend_argv</varname> 
is a null terminated list of arguments to pass to the back-end application upon 
creation. If <varname>backend_exe</varname>
is NULL, no back-end processes will be started, and the leaves of the topology
specified by <varname>topology</varname> will be instances of <filename>mrnet_commnode</filename>. 
</para>
<para>
<varname>rank_backends</varname> indicates whether the back-end
process ranks should begin at 0, similar to MPI rank numbering, and defaults to true. 
</para>
<para>
If <varname>using_memory_buffer</varname> is set to true (default is false), 
the <varname>topology</varname> parameter is actually a pointer to a memory buffer 
containing the topology specification, rather than the name of a file. 
</para>
<para>
When this function completes without error, 
all MRNet processes specified in the topology will have been instantiated. You may
use <function>Network::has_error()</function> to check for successful completion.
</para>
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>Network::Network</function></funcdef>
    <paramdef>int <parameter>argc</parameter></paramdef>
    <paramdef>char ** <parameter>argv</parameter></paramdef>
</funcprototype>
<blockquote>
The back-end constructor method that is used when the process is started due to a 
front-end Network instantiation. MRNet automatically passes the necessary 
information to the process using the program argument vector 
(<varname>argc/argv</varname>) by inserting it after the user-specified arguments. 
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>Network::Network</function></funcdef>
    <paramdef>const char * <parameter>parent_hostname</parameter></paramdef>
    <paramdef>Port <parameter>parent_port</parameter></paramdef>
    <paramdef>Rank <parameter>parent_rank</parameter></paramdef>
    <paramdef>const char * <parameter>my_hostname</parameter></paramdef>
    <paramdef>Rank <parameter>my_rank</parameter></paramdef>
</funcprototype>
<blockquote>
<para>The back-end constructor method that is used to attach to an instantiated MRNet process tree,
as is necessary when the back-end processes are not started as part of a front-end Network
instantiation.
</para>
<para>
<varname>parent_hostname</varname> is the name of the host where the parent
process is running. <varname>parent_port</varname> and <varname>parent_rank</varname> are the 
port number and rank of the parent process, respectively.
Information about the tree processes
to which back-ends should connect can be gathered by the front-end using the NetworkTopology
object returned from <function>Network::get_NetworkTopology</function>. 
</para>
<para>
<varname>my_hostname</varname> is the name of the host on which the back-end process is running,
and <varname>my_rank</varname> is an arbitrary rank chosen by the back-end to not conflict with
the ranks of existing tree processes.
</para>
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>Network::~Network</function></funcdef>
  <void></void>
</funcprototype>
<blockquote>
<function>Network::~Network</function> is used to tear down the
MRNet process tree and clean up the Network object. The first action
taken by the destructor is to invoke <function>Network::shutdown_Network</function>.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>Network::shutdown_Network</function></funcdef>
  <void></void>
</funcprototype>
<blockquote>
<function>Network::shutdown_Network</function> is used to tear down the
MRNet process tree. When this function is called, each node in the
tree sends a control message to its immediate children
informing them of the "shutdown network" request, and waits for confirmation. 
If the node is an internal process (i.e., mrnet_commnode), the process will then terminate.
If the node is an application back-end, the process will terminate unless
a separate call to <function>Network::set_TerminateBackEndsOnShutdown</function>
has been made to request otherwise.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>Network::set_TerminateBackEndsOnShutdown</function></funcdef>
   <paramdef>bool <parameter>terminate</parameter></paramdef>
</funcprototype>
<blockquote>
<function>Network::set_TerminateBackEndsOnShutdown</function> is used to
control whether application back-end processes are terminated when the MRNet
Network is shutdown. By default, back-end processes will be terminated. If this
behavior is not desired, call this method with <varname>terminate</varname> set to false.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>bool <function>Network::has_error</function></funcdef>
  <void></void>
</funcprototype>
<blockquote>
<function>Network::has_error</function> returns true if an error has
occured during the last call to a <classname>Network</classname> method. 
<function>Network::print_error</function>
can be used to print a message describing the exact error. 
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>Network::print_error</function></funcdef>
  <paramdef>const char * <parameter>error_msg</parameter></paramdef>
</funcprototype>
<blockquote>
<function>Network::print_error</function> prints a message to stderr
describing the last error encountered during a <classname>Network</classname>
 method. It first prints the null-terminated string, <varname>error_msg</varname>
followed by a colon then the actual error message followed by a newline.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>std::string <function>Network::get_LocalHostName</function></funcdef>
  <void></void>
</funcprototype>
<blockquote>
<function>Network::get_LocalHostName</function> returns the name of the host
on which the MRNet process is running.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>Port <function>Network::get_LocalPort</function></funcdef>
  <void></void>
</funcprototype>
<blockquote>
<function>Network::get_LocalPort</function> returns the port at which the 
MRNet process can be contacted.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>Rank <function>Network::get_LocalRank</function></funcdef>
  <void></void>
</funcprototype>
<blockquote>
<function>Network::get_LocalRank</function> returns the rank of the
MRNet process.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>int <function>Network::load_FilterFunc</function></funcdef>
    <paramdef>const char * <parameter>so_file</parameter></paramdef>
    <paramdef>const char * <parameter>func_name</parameter></paramdef>
    <paramdef>bool <parameter>is_transformation_filter</parameter> =true</paramdef>
</funcprototype>
<blockquote>
<para>
This method, used for loading new filter operations into the Network
is conveniently similar to the conventional <function>dlopen()
</function> facilities for opening a shared object and dynamically
loading symbols defined within. 
</para>
<para>
<varname>so_file</varname> is the path to a shared object file that contains
the filter function to be loaded and <varname>func_name</varname> is the name of the
function to be loaded. The last parameter <varname>is_transformation_filter
</varname> defaults to true and can usually be omitted since the common case
is to load transformation, not synchronization, filters.
</para>

<para>
On success, <function>Network::load_FilterFunc</function> returns the id
of the newly loaded filter which may be used in subsequent calls to
<function>Network::new_Stream</function>. A value of -1 is returned
on failure.
</para>
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>int <function>Network::recv</function></funcdef>
    <paramdef>int * <parameter>tag</parameter></paramdef>
    <paramdef>PacketPtr &amp; <parameter>packet</parameter></paramdef>
    <paramdef>Stream ** <parameter>stream</parameter></paramdef>
    <paramdef>bool <parameter>blocking</parameter> =true</paramdef>
</funcprototype>
<blockquote>
<para>
<function>Network::recv</function> is used to invoke a stream-anonymous
receive operation. Any packet available (addressed to any stream)
will be returned (in roughly FIFO ordering) via the output parameters. 
</para>
<para>
<varname>otag</varname> will be filled in with the integer
tag value that was passed by the corresponding <function>Stream::send()
</function> operation. <varname>packet</varname> is the packet that was
received. A pointer to the Stream to which the packet was addressed
will be returned in <varname>stream</varname>. 
</para>
<para>
<varname>blocking</varname>
is used to signal whether this call should block or return if data is not
immediately available; it defaults to a blocking call.
</para>
<para>
A return value of -1 indicates an error, 0 indicates no packets were 
available, and 1 indicates success.
</para>
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>bool <function>Network::enable_PerformanceData</function></funcdef>
  <paramdef>perfdata_metric_t <parameter>metric</parameter></paramdef>
  <paramdef>perfdata_context_t <parameter>context</parameter></paramdef>
</funcprototype>
<blockquote>
<function>Network::enable_PerformanceData</function> uses
<function>Stream::enable_PerformanceData</function> to start the recording
of performance data of the specified <varname>metric</varname> type for the
given <varname>context</varname> on all streams. Returns true on success,
false otherwise.
<xref linkend="perf_data"></xref> describes the supported metric and context types.
See <function>Stream::enable_PerformanceData</function> for additional details.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>bool <function>Network::disable_PerformanceData</function></funcdef>
  <paramdef>perfdata_metric_t <parameter>metric</parameter></paramdef>
  <paramdef>perfdata_context_t <parameter>context</parameter></paramdef>
</funcprototype>
<blockquote>
<function>Network::disable_PerformanceData</function> uses
<function>Stream::disable_PerformanceData</function> to stop the recording
of performance data of the specified <varname>metric</varname> type for the
given <varname>context</varname> on all streams. Returns true on success,
false otherwise. See 
<function>Stream::disable_PerformanceData</function> for additional details.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>bool <function>Network::collect_PerformanceData</function></funcdef>
  <paramdef>std::map&lt; int, rank_perfdata_map &gt; &amp; <parameter>results</parameter></paramdef>
  <paramdef>perfdata_metric_t <parameter>metric</parameter></paramdef>
  <paramdef>perfdata_context_t <parameter>context</parameter></paramdef>
  <paramdef>int <parameter>aggr_filter_id</parameter> =TFILTER_ARRAY_CONCAT</paramdef>
</funcprototype>
<blockquote>
<function>Network::collect_PerformanceData</function> uses
<function>Stream::collect_PerformanceData</function> to collect the 
performance data of the specified <varname>metric</varname> type for the
given <varname>context</varname> on all streams. The performance data of 
each stream is passed through the transformation filter identified by 
<varname>aggr_filter_id</varname>. The data for all streams is stored within
the map <varname>results</varname>, keyed by stream identifier. Returns true on success,
false otherwise.
See <function>Stream::collect_PerformanceData</function> for additional details.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>Network::print_PerformanceData</function></funcdef>
  <paramdef>perfdata_metric_t <parameter>metric</parameter></paramdef>
  <paramdef>perfdata_context_t <parameter>context</parameter></paramdef>
</funcprototype>
<blockquote>
<function>Network::enable_PerformanceData</function> uses
<function>Stream::print_PerformanceData</function> to print recorded
performance data of the specified <varname>metric</varname> type for the
given <varname>context</varname> on all streams. Data is printed to the
MRNet log files. See <function>Stream::print_PerformanceData</function> 
for additional details.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>Network::get_EventNotificationFd</function></funcdef>
  <paramdef>EventType <parameter>etyp</parameter></paramdef>
</funcprototype>
<blockquote>
<para><function>Network::get_EventNotificationFd</function> returns a file descriptor
that can be added to the <literal>read fd_set</literal> of  <function>select()</function> 
to receive notification of interesting DATA, TOPOLOGY, or ERROR events.
</para>
<para>
<varname>etyp</varname> should be set to one of <literal>ERROR_EVENT</literal>, 
<literal>DATA_EVENT</literal>, or <literal>TOPOLOGY_EVENT</literal>.
<literal>DATA_EVENT</literal> can be used by both front-end and back-end
processes to provide notification that one or more data packets have been received. 
<literal>TOPOLOGY_EVENT</literal> and <literal>ERROR_EVENT</literal> can only be used
by front-end processes, and provide notification when the front-end observes a change in 
<classname>NetworkTopology</classname> or an error, respectively.</para>
<para> When <function>select()</function> indicates that the file descriptor has data 
available, you should call <function>Network::clear_EventNotificationFd</function> before
taking action on the notification. When notifications are no longer needed, use
<function>Network::close_EventNotificationFd</function></para>
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>Network::clear_EventNotificationFd</function></funcdef>
  <paramdef>EventType <parameter>etyp</parameter></paramdef>
</funcprototype>
<blockquote>
This method resets the event notification
file descriptor returned from <function>Network::get_EventNotificationFd</function>.
<varname>etyp</varname> should be set to one of <literal>ERROR_EVENT</literal>, 
<literal>DATA_EVENT</literal>, or <literal>TOPOLOGY_EVENT</literal>.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>Network::close_EventNotificationFd</function></funcdef>
  <paramdef>EventType <parameter>etyp</parameter></paramdef>
</funcprototype>
<blockquote>
This method closes the event notification
file descriptor returned from <function>Network::get_EventNotificationFd</function>.
<varname>etyp</varname> should be set to one of <literal>ERROR_EVENT</literal>, 
<literal>DATA_EVENT</literal>, or <literal>TOPOLOGY_EVENT</literal>.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>Network::get_DataSocketFds</function></funcdef>
  <paramdef>int ** <parameter>fd_array</parameter></paramdef>
  <paramdef>unsigned int * <parameter>fd_array_size</parameter></paramdef>
</funcprototype>
<blockquote>
<function>Network::get_DataSocketFds</function> is deprecated and has been removed.
See <function>Network::get_EventNotificationFd</function> for a description of
how to receive notifications for <literal>DATA_EVENT</literal>s.
</blockquote>
</funcsynopsis>

</sect1>


<sect1 id="sect:net_topol_api"> <title>Class NetworkTopology</title>

<para>
Instances of NetworkTopology are network specific, so they are created 
when a Network is instantiated. MRNet API users should not need to
create their own NetworkTopology instances.
</para>

<funcsynopsis>
<funcprototype>
  <funcdef>NetworkTopology * <function>Network::get_NetworkTopology</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
<function>Network::get_NetworkTopology</function> is used to retrieve 
a pointer to the underlying NetworkTopology instance of a Network.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>unsigned int <function>NetworkTopology::get_NumNodes</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
This method returns the total number of nodes in the tree topology, 
including front-end, internal, and back-end processes.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>NetworkTopology::Node * <function>NetworkTopology::find_Node</function></funcdef>
    <paramdef>Rank <parameter>node_rank</parameter></paramdef>
</funcprototype>
<blockquote>
This method returns a pointer to the tree node with rank equal to <varname>node_rank</varname>,
or NULL if not found.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>NetworkTopology::Node * <function>NetworkTopology::get_Root</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
This method returns a pointer to the root node of the tree,
or NULL if not found.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>NetworkTopology::get_Leaves</function></funcdef>
    <paramdef>std::vector&lt; NetworkTopology::Node * &gt; &amp; <parameter>leaves</parameter></paramdef>
</funcprototype>
<blockquote>
This method fills in the <varname>leaves</varname> vector with pointers to the
leaf nodes in the topology. In the case where back-end processes are not
started when the Network is instantiated, a front-end process can use this 
function to retrieve information about the leaf internal processes to which
the back-ends should attach.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>NetworkTopology::get_BackEndNodes</function></funcdef>
    <paramdef>std::set&lt; NetworkTopology::Node * &gt; &amp; <parameter>nodes</parameter></paramdef>
</funcprototype>
<blockquote>
This method fills a set with pointers to all back-end process tree nodes.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>NetworkTopology::get_ParentNodes</function></funcdef>
    <paramdef>std::set&lt; NetworkTopology::Node * &gt; &amp; <parameter>nodes</parameter></paramdef>
</funcprototype>
<blockquote>
This method fills a set with pointers to all tree nodes that are parents
(i.e., those nodes having at least one child).
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>NetworkTopology::get_OrphanNodes</function></funcdef>
    <paramdef>std::set&lt; NetworkTopology::Node * &gt; &amp; <parameter>nodes</parameter></paramdef>
</funcprototype>
<blockquote>
This method fills a set with pointers to all tree nodes that have
no parent due to a failure.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>NetworkTopology::get_TreeStatistics</function></funcdef>
    <paramdef>unsigned int &amp; <parameter>num_nodes</parameter></paramdef>
    <paramdef>unsigned int &amp; <parameter>depth</parameter></paramdef>
    <paramdef>unsigned int &amp; <parameter>min_fanout</parameter></paramdef>
    <paramdef>unsigned int &amp; <parameter>max_fanout</parameter></paramdef>
    <paramdef>double &amp; <parameter>avg_fanout</parameter></paramdef>
    <paramdef>double &amp; <parameter>stddev_fanout</parameter></paramdef>  
</funcprototype>
<blockquote>
<para>
This method provides users statistics about the tree topology by filling
the supplied parameters.
</para>
<para>
<varname>num_nodes</varname>
is the total number of tree nodes (same as the value returned by 
<function>NetworkTopology::get_NumNodes</function>), <varname>depth</varname> is the 
depth of the tree (i.e., the maximum path length from root to any leaf), <varname>min_fanout</varname>
is the minimum number of children of any parent node, <varname>max_fanout</varname> is the
maximum number of children of any parent node, <varname>avg_fanout</varname> is the average
number of children across all parent nodes, and <varname>stddev_fanout</varname> is the standard
deviation in number of children across all parent nodes.
</para>
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>NetworkTopology::print_TopologyFile</function></funcdef>
    <paramdef>const char * <parameter>filename</parameter></paramdef>
</funcprototype>
<blockquote>
This method will create (or overwrite) the specified topology file 
<varname>filename</varname> using the current state of this 
<classname>NetworkTopology</classname> object.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>NetworkTopology::print_DOTGraph</function></funcdef>
    <paramdef>const char * <parameter>filename</parameter></paramdef>
</funcprototype>
<blockquote>
This method will create (or overwrite) the specified dot graph file 
<varname>filename</varname> using the current state of this 
<classname>NetworkTopology</classname> object.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>std::string <function>NetworkTopology::Node::get_HostName</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
This method returns a character string identifying the hostname of the tree node.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>Port <function>NetworkTopology::Node::get_Port</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
This method returns the connection port of the tree node.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>Rank <function>NetworkTopology::Node::get_Rank</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
This method returns the unique rank of the tree node.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>const std::set&lt; NetworkTopology::Node * &gt; &amp; <function>NetworkTopology::Node::get_Children</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
This method returns a set containing pointers to the children of the tree node, and is useful
for navigating through the tree.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>unsigned int <function>NetworkTopology::Node::get_NumChildren</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
This method returns the number of children of the tree node.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>unsigned int <function>NetworkTopology::Node::find_SubTreeHeight</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
This method returns the height of the subtree rooted at this tree node.
</blockquote>
</funcsynopsis>

</sect1>


<sect1 id="sect:comm_api"><title>Class Communicator</title>

<para>
Instances of Communicator are network specific, so their creation methods
are functions of an instantiated Network object.
</para>

<funcsynopsis>
<funcprototype>
  <funcdef>Communicator * <function>Network::new_Communicator</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
This method returns a pointer to a new Communicator object. The object
initially contains <emphasis>no</emphasis> end-points. Use <function>
Communicator::add_EndPoint</function> to populate the Communicator.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>Communicator * <function>Network::new_Communicator</function></funcdef>
    <paramdef>Communicator &amp; <parameter>comm</parameter></paramdef>
</funcprototype>
<blockquote>
This method returns a pointer to a new Communicator object that initially
contains the set of end-points contained in <varname>comm</varname>.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>Communicator * <function>Network::new_Communicator</function></funcdef>
    <paramdef>std::set&lt; CommunicationNode * &gt; &amp; <parameter>endpoints</parameter></paramdef>
</funcprototype>
<blockquote>
This method returns a pointer to a new Communicator object that initially
contains the set of end-points contained in <varname>endpoints</varname>.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>Communicator * <function>Network::get_BroadcastCommunicator</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
<para>
This method returns a pointer to a default broadcast Communicator containing all the
end-points available in the system at the time the function is called. </para>
<para>
Multiple calls to 
this function return the same pointer to the broadcast 
communicator object created at network instantiation. If the Network's topology changes,
as can occur when starting back-ends separately, the object will be updated to reflect
the additions or deletions. This object should not be deleted.</para>
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>bool <function>Communicator::add_EndPoint</function></funcdef>
    <paramdef>Rank <parameter>ep_rank</parameter></paramdef>
</funcprototype>
<blockquote>
<para>
This method is used to add an existing end-point with rank 
<varname>ep_rank</varname> to the set contained
by the Communicator. </para>
<para>The original set of end-points contained by the
Communicator is tested to see if it already contains the potentially
new end-point. If so, the function silently returns successfully.
This method fails if there exists no end-point defined by
<varname>ep_rank</varname>. This method returns true on success, false 
on failure.</para>
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>bool <function>Communicator::add_EndPoint</function></funcdef>
    <paramdef>CommunicationNode * <parameter>endpoint</parameter></paramdef>
</funcprototype>
<blockquote>
This method is similar to the <function>add_EndPoint()</function>
above except that it takes a pointer to a CommunicationNode object 
instead of a rank. Success and failure conditions are exactly as stated above. 
This method also returns true on success and false on failure.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>const std::set&lt; CommunicationNode * &gt; &amp; <function>Communicator::get_EndPoints</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
This method returns a reference to the set of CommunicationNode pointers comprising
the end-points in the Communicator.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>std::string <function>CommunicationNode::get_HostName</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
This method returns a character string identifying the hostname of the
end-point represented by this CommunicationNode.
is out of range.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>Port <function>CommunicationNode::get_Port</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
This method returns the connection port of the end-point 
represented by this CommunicationNode.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>Rank <function>CommunicationNode::get_Rank</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
This method returns the unique rank of the end-point 
represented by this CommunicationNode.
</blockquote>
</funcsynopsis>
</sect1>

<sect1 id="sect:stream_api"><title>Class Stream</title>

<para>
Instances of Stream are network specific, so their creation methods
are functions of an instantiated Network object.  There are two common approaches to
creating a new stream.
</para>

<funcsynopsis>
<funcprototype>
  <funcdef>Stream * <function>Network::new_Stream</function></funcdef>
    <paramdef>Communicator * <parameter>comm</parameter></paramdef>
    <paramdef>int <parameter>up_transfilter_id</parameter> =TFILTER_NULL</paramdef>
    <paramdef>int <parameter>up_syncfilter_id</parameter> =SFILTER_WAITFORALL</paramdef>
    <paramdef>int <parameter>down_transfilter_id</parameter> =TFILTER_NULL</paramdef>
</funcprototype>
<blockquote>
<para>
This version of <function>Network::new_Stream()</function> is the straightforward way to
create a Stream object attached to the end-points specified by a Communicator object 
<varname>comm</varname>.
</para>
<para><varname>up_transfilter_id</varname> specifies the
transformation filter to apply to data flowing upstream from the application 
back-ends toward the front-end; the default value is <literal>TFILTER_NULL</literal>.
</para>
<para><varname>up_syncfilter_id</varname> specifies the synchronization filter to apply 
to upstream packets; the default value is <literal>SFILTER_WAITFORALL</literal>. 
</para>
<para><varname>down_transfilter_id</varname> allows the user to specify a filter to apply 
to downstream data flows; the default value is <literal>TFILTER_NULL</literal>.</para>
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>Stream * <function>Network::new_Stream</function></funcdef>
    <paramdef>Communicator * <parameter>comm</parameter></paramdef>
    <paramdef>std::string <parameter>us_filters</parameter></paramdef>
    <paramdef>std::string <parameter>sync_filters</parameter></paramdef>
    <paramdef>std::string <parameter>ds_filters</parameter></paramdef>
</funcprototype>
<blockquote>
<para>
This version of <function>Network::new_Stream()</function> allows the user
to map arbitrary packet filters to arbitrary nodes within the tree.  Strings
are used to express these mappings, with the following syntax: <function>"filter_id_1 => node_rank_1;
filter_id_2 => node_rank_2;"</function>.  Like the simpler version of
<function>Network::new_Stream()</function>, the end-points are specified by the
<varname>comm</varname> argument.  See HeterogeneousFilters under the Examples directory to see
a <function>Network::new_Stream()</function> call that specifies different filter types to be used
within the same stream.</para>
<para><varname>us_filters</varname> specifies the
transformation filter(s) to apply to data flowing upstream from the application 
back-ends toward the front-end.
</para>
<para><varname>sync_filters</varname> specifies the synchronization filter(s) to apply 
to upstream packets.
</para>
<para><varname>ds_filters</varname> allows the user to specify a filter to apply 
to downstream data flows.</para>
<para>Note that more than one filter should not be assigned to a single node in any of these strings.</para>
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>Stream * <function>Network::get_Stream</function></funcdef>
    <paramdef>unsigned int <parameter>iid</parameter></paramdef>
</funcprototype>
<blockquote>
<function>Network::get_Stream()</function> returns a pointer to the Stream 
identified by <varname>id</varname>, or NULL on failure.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>unsigned int <function>Stream::get_Id</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
This method returns the integer identifier for this Stream.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>const std::set&lt; Rank &gt; &amp; <function>Stream::get_EndPoints</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
This method returns the set of end-point ranks for this Stream.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>unsigned int <function>Stream::size</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
This method returns an integer indicating the number of end-points for this Stream.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>int <function>Stream::send</function></funcdef>
    <paramdef>int <parameter>tag</parameter></paramdef>
    <paramdef>const char * <parameter>format_string</parameter></paramdef>
    <varargs></varargs>
</funcprototype>
<blockquote>
This method invokes a data send operation on the calling Stream.
<varname>tag</varname> is an integer identifier that is expected
to classify the data in the packet to be transmitted across the Stream.
<varname>format_string</varname> is a format string describing the data
in the packet (See <xref linkend="format_strings"></xref>
for a full description.) On success, <function>Stream::send()</function>
returns 0; on failure -1.
<note>
<varname>tag</varname> must have a value greather than or equal to the
constant <literal>FirstApplicationTag</literal> defined by MRNet 
(<filename>#include "mrnet/Types.h"</filename>). Tag values less than
<literal>FirstApplicationTag</literal> are reserved for internal MRNet use.
</note>
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>int <function>Stream::recv</function></funcdef>
    <paramdef>int * <parameter>tag</parameter></paramdef>
    <paramdef>PacketPtr &amp; <parameter>packet</parameter></paramdef>
    <paramdef>bool <parameter>blocking</parameter> =true</paramdef>
</funcprototype>
<blockquote>
<para>
<function>Stream::recv()</function> invokes a stream-specific
receive operation. Packets addressed to the calling stream
will be returned in strictly FIFO ordering via the output parameters. 
</para>
<para>
<varname>tag</varname> will be filled in with the integer
tag value that was passed by the corresponding <function>Stream::send()
</function> operation. <varname>packet</varname> is the recieved Packet. 
</para>
<para>
<varname>blocking</varname> determines whether the receive should block 
or return if data is not immediately available; it defaults to a blocking call. 
</para>
<para>
A return value of -1 indicates an error, 0 indicates no packets were 
available, and 1 indicates success.</para>
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>int <function>Stream::flush</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
Commits a flush of all packets currently buffered by the stream
pending an output operation. A successful return value of 1 
indicates that all packets on the calling stream have been passed 
to the operating system for network transmission.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>int <function>Stream::set_FilterParameters</function></funcdef>
    <paramdef>bool <parameter>upstream</parameter></paramdef>
    <paramdef>const char * <parameter>format_string</parameter></paramdef>
    <varargs></varargs>
</funcprototype>
<blockquote>
<para><function>Stream::set_FilterParameters</function> allows users to dynamically
configure the operation of a Stream transformation filter by passing arbitrary data
in a similar fashion to <function>Stream::send</function>. When the filter executes, the
passed data is available as a PacketPtr parameter to the filter, and the
filter can extract the configuration settings. 
</para>
<para>When set to true, <varname>upstream</varname>
indicates the upstream transformation filter should be updated, while a 
value of false will update the downstream transformation filter.</para>
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>bool <function>Stream::enable_PerformanceData</function></funcdef>
  <paramdef>perfdata_metric_t <parameter>metric</parameter></paramdef>
  <paramdef>perfdata_context_t <parameter>context</parameter></paramdef>
</funcprototype>
<blockquote>
<function>Stream::enable_PerformanceData</function> starts recording
performance data for the specified <varname>metric</varname> type for the
given <varname>context</varname>.  Returns true on success,
false otherwise. <xref linkend="perf_data"></xref> describes 
the supported metric and context types.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>bool <function>Stream::disable_PerformanceData</function></funcdef>
  <paramdef>perfdata_metric_t <parameter>metric</parameter></paramdef>
  <paramdef>perfdata_context_t <parameter>context</parameter></paramdef>
</funcprototype>
<blockquote>
<function>Stream::disable_PerformanceData</function> stops recording
performance data for the specified <varname>metric</varname> type for the
given <varname>context</varname>. Previously recorded data is not
discarded, so that it can be retrieved with 
<function>Stream::collect_PerformanceData</function>. Users can enable/disable
recording for a particular <varname>metric</varname> and 
<varname>context</varname> any number of times before collecting the results. 
Returns true on success, false otherwise.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>bool <function>Stream::collect_PerformanceData</function></funcdef>
  <paramdef>rank_perfdata_map&amp; <parameter>results</parameter></paramdef>
  <paramdef>perfdata_metric_t <parameter>metric</parameter></paramdef>
  <paramdef>perfdata_context_t <parameter>context</parameter></paramdef>
  <paramdef>int <parameter>aggr_filter_id</parameter> =TFILTER_ARRAY_CONCAT</paramdef>
</funcprototype>
<blockquote>
<para><function>Stream::collect_PerformanceData</function> collects the recorded
performance data for the specified <varname>metric</varname> type for the
given <varname>context</varname>. The collected data is stored within a
<varname>rank_perfdata_map</varname>, which associates individual Ranks to a 
<varname>std::vector&lt; perf_data_t &gt;</varname> containing the recorded
data instances. After collection, the recorded data at each Rank is discarded. 
Returns true on success, false otherwise.</para> 

<para>Users can aggregate the recorded data across Ranks by specifying a 
transformation filter with <varname>aggr_filter_id</varname>. Note that
 only the built-in filter types of <literal>TFILTER_SUM</literal>, 
<literal>TFILTER_MIN</literal>, <literal>TFILTER_MAX</literal>, 
<literal>TFILTER_AVG</literal>, and <literal>TFILTER_ARRAY_CONCAT</literal> 
are supported. By default, performance data from each Rank is concatenated,
and <varname>results</varname> contains every recorded data instance for
each Rank. If the summary aggregation filters are used, 
<varname>results</varname> will contain a single associated pair. The
Rank for this pair is equal to <literal>-1*(number of aggregated ranks)</literal>,
and the vector contains one or more aggregated instances. </para>
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>Stream::print_PerformanceData</function></funcdef>
  <paramdef>perfdata_metric_t <parameter>metric</parameter></paramdef>
  <paramdef>perfdata_context_t <parameter>context</parameter></paramdef>
</funcprototype>
<blockquote>
<function>Stream::print_PerformanceData</function> prints recorded
performance data of the specified <varname>metric</varname> type for the
given <varname>context</varname>. At each Rank, the data is printed to the
MRNet log files and then discarded.
</blockquote>
</funcsynopsis>

</sect1>


<sect1 id="sect:packet_api"><title>Class Packet</title>

<para>
A Packet encapsulates a chunk of formatted data sent on a Stream. 
Packets are created using a format string (e.g., 
<literal>"%s %d"</literal> describes a null-terminated string followed
by a 32-bit integer, and the Packet is said to contain 2 data elements).
MRNet front-end and back-end processes do not create instances of Packet; 
instead they are automatically produced from the 
formatted data passed to <function>Stream::send</function>.
<xref linkend="format_strings"></xref> contains the full listing of data types
that can be sent in a Packet.
</para>
<para>
When receiving a Packet via <function>Stream::recv</function> or 
<function>Network::recv</function>,
the Packet instance is stored within a PacketPtr object. PacketPtr is a class
based on the Boost library shared_ptr class, and helps with memory management 
of Packets. A PacketPtr can be assumed to be equivalent to "Packet *", and 
all operations on Packets require use of PacketPtr.
</para>

<funcsynopsis>
<funcprototype>
  <funcdef>int <function>Packet::get_Tag</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
This method returns the integer tag associated with the Packet.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>unsigned short <function>Packet::get_StreamId</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
This method returns the stream id associated with the Packet.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>const char * <function>Packet::get_FormatString</function></funcdef>
    <void></void>
</funcprototype>
<blockquote>
This method returns the character string specifying the data format of the Packet.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>Packet::unpack</function></funcdef>
    <paramdef>const char * <parameter>format_string</parameter></paramdef>
    <varargs></varargs>
</funcprototype>
<blockquote>
This method extracts data contained within a Packet according to the 
<varname>format_string</varname>, which must match that of the Packet.
The function arguments following <varname>format_string</varname> should
be pointers to the appropriate types of each data item. For string and
array data types, new memory buffers to hold the data will be allocated 
using <function>malloc()</function>, and it is the user's responsibility
to <function>free()</function> these strings and arrays.
</blockquote>
</funcsynopsis>

<funcsynopsis>
<funcprototype>
  <funcdef>void <function>Packet::set_DestroyData</function></funcdef>
    <paramdef>bool <parameter>destroy</parameter></paramdef>
    <varargs></varargs>
</funcprototype>
<blockquote>
This method can be used to tell MRNet whether or not to deallocate the
string and array data members of a Packet. If <varname>destroy</varname> is true,
string and array data members will be deallocated using <function>free()</function>
when the Packet destructor is executed. Note this assumes they were allocated 
using <function>malloc()</function>. The default behavior for user-generated
Packets is not to deallocate (false). 
Turning on deallocation is useful in filter code that must allocate strings or
arrays for output Packets, which cannot be freed before the filter function returns.
</blockquote>
</funcsynopsis>

</sect1>

</chapter>

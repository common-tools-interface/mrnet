<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>The Multicast/Reduction Network: A User's Guide to MRNet v2.1</title><meta name="generator" content="DocBook XSL Stylesheets V1.73.2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="book"></a>The Multicast/Reduction Network: A User's Guide to MRNet v2.1</h1></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#id2509777">1. Introduction</a></span></dt><dt><span class="chapter"><a href="#id2514471">2. Installing and Using MRNet</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id2477810">Supported Platforms and Compilers</a></span></dt><dt><span class="sect1"><a href="#id2477605">System Requirements</a></span></dt><dt><span class="sect1"><a href="#id2476169">Build Configuration</a></span></dt><dt><span class="sect1"><a href="#id2476286">Compilation and Installation</a></span></dt><dt><span class="sect1"><a href="#id2523875">Testing the Code</a></span></dt><dt><span class="sect1"><a href="#id2523942">Bugs, Questions and Comments</a></span></dt></dl></dd><dt><span class="chapter"><a href="#id2476136">3. MRNet Components and Abstractions</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id2476082">End-Points</a></span></dt><dt><span class="sect1"><a href="#id2476096">Communicators</a></span></dt><dt><span class="sect1"><a href="#id2524651">Streams</a></span></dt><dt><span class="sect1"><a href="#id2524676">Filters</a></span></dt></dl></dd><dt><span class="chapter"><a href="#simple_example">4. A Simple Example</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id2524487">The MRNet Interface</a></span></dt><dt><span class="sect1"><a href="#mrnet_instantiation">MRNet Instantiation</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mrnet_api">5. The MRNet C++ API Reference</a></span></dt><dd><dl><dt><span class="sect1"><a href="#sect:network_api">Class Network</a></span></dt><dt><span class="sect1"><a href="#sect:net_topol_api">Class NetworkTopology</a></span></dt><dt><span class="sect1"><a href="#sect:comm_api">Class Communicator</a></span></dt><dt><span class="sect1"><a href="#sect:stream_api">Class Stream</a></span></dt><dt><span class="sect1"><a href="#sect:packet_api">Class Packet</a></span></dt></dl></dd><dt><span class="chapter"><a href="#mrnet_topology_configuration">6. MRNET Process-tree
Topologies</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id2531347">Topology File Format</a></span></dt><dt><span class="sect1"><a href="#id2532016">Topology File Generator</a></span></dt></dl></dd><dt><span class="chapter"><a href="#adding_filters">7. Adding New Filters</a></span></dt><dd><dl><dt><span class="sect1"><a href="#id2532118">Defining an MRNet Filter</a></span></dt><dt><span class="sect1"><a href="#id2532396">Creating and Using MRNet Filter Shared Object Files</a></span></dt></dl></dd><dt><span class="appendix"><a href="#format_strings">A. MRNet Format Strings</a></span></dt><dt><span class="appendix"><a href="#perf_data">B. MRNet Stream Performance Data</a></span></dt><dt><span class="appendix"><a href="#example">C. A Complete MRNet Example: Integer Addition</a></span></dt><dt><span class="appendix"><a href="#env_vars">D. Environment Variables</a></span></dt></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>B.1. <a href="#id2533448">Metric-Context Compatibility Matrix</a></dt></dl></div><div class="list-of-examples"><p><b>List of Examples</b></p><dl><dt>4.1. <a href="#fe_code">MRNet Front-end Sample Code</a></dt><dt>4.2. <a href="#be_code">MRNet Back-end Sample Code</a></dt><dt>C.1. <a href="#id2533332">A Complete MRNet Front-End</a></dt><dt>C.2. <a href="#id2533247">A Complete MRNet Back-End</a></dt><dt>C.3. <a href="#id2533280">An MRNet Filter: Integer Addition</a></dt><dt>C.4. <a href="#id2534344">An MRNet Topology File</a></dt></dl></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2509777"></a>Chapter 1. Introduction</h2></div></div></div><p>
MRNet is a customizable, high-throughput communication software system for
parallel tools and applications with a master/slave architecture. 
MRNet reduces the cost of these
tools' activities by incorporating a tree-based overlay network (TBON) of processes 
between the tool's front-end and back-ends. MRNet uses the TBON to distribute many
important tool communication anc computation activities, reducing analysis time and 
keeping tool front-end loads manageable.
</p><p>
MRNet-based tools send data between front-end and back-ends on logical flows of
data called streams. MRNet internal processes use filters to synchronize and
aggregate data sent to the tool's front-end. Using filters to manipulate data in
parallel as it passes through the network, MRNet can efficiently compute
averages, sums, and other more complex aggregations on back-end data.
</p><p>
Several features make MRNet especially well-suited as a general facility for
building scalable parallel tools:
</p><div class="itemizedlist"><ul type="disc"><li><span class="emphasis"><em>Flexible organization.</em></span> MRNet does not dictate
the organization of the TBON. MRNet process organization is
specified in a configuration file that can specify common network overlays like
k-ary and k-nomial trees, or custom layouts tailored to the system(s) running
the tool. For example, MRNet internal processes can be allocated to dedicated
system nodes or co-located with tool back-end and application processes.
</li><li><span class="emphasis"><em>Scalable, flexible data aggregation.</em></span> MRNet's
built-in filters provide efficient computation of averages, sums, concatenation,
and other common data reductions. Custom filters can be loaded dynamically into
the network to perform tool-specific aggregation operations. </li><li><span class="emphasis"><em>High-bandwidth communication.</em></span> MRNet transfers data
within the tool system using an efficient, packed binary representation.
Zero-copy data paths are used whenever possible to reduce the cost of
transferring data through internal processes.</li><li><span class="emphasis"><em>Scalable multicast</em></span>. As the number of back-ends
increases, serialization when sending control requests limits the scalability of
existing tools. MRNet supports efficient message multicast to reduce the cost of
issuing control requests from the tool front-end to its back-ends.</li><li><span class="emphasis"><em>Multiple concurrent data channels.</em></span> MRNet supports
multiple logical streams of data between tool components. Data aggregation and
message multicast takes place within the context of a data stream, and multiple
operations (both upward and downward) can be active simultaneously.</li></ul></div><p>
</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2514471"></a>Chapter 2. Installing and Using MRNet</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id2477810">Supported Platforms and Compilers</a></span></dt><dt><span class="sect1"><a href="#id2477605">System Requirements</a></span></dt><dt><span class="sect1"><a href="#id2476169">Build Configuration</a></span></dt><dt><span class="sect1"><a href="#id2476286">Compilation and Installation</a></span></dt><dt><span class="sect1"><a href="#id2523875">Testing the Code</a></span></dt><dt><span class="sect1"><a href="#id2523942">Bugs, Questions and Comments</a></span></dt></dl></div><p>
For this discussion, <code class="envar">$MRNET_ROOT</code> is the location of the
top-level directory of the MRNet distribution and
<code class="envar">$MRNET_ARCH</code> is a string describing the platform (OS and
architecture) as discovered by autoconf. For the installation instructions, it is
assumed that the current working directory is <code class="envar">$MRNET_ROOT</code>.
</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2477810"></a>Supported Platforms and Compilers</h2></div></div></div><p>
MRNet has been developed to be highly portable; we expect it to run properly
on all common Unix-based as well as Microsoft Windows platforms. This being said, 
we have successfully built and tested MRNet on the following systems:
</p><div class="itemizedlist"><ul type="disc"><li>i686-pc-linux-gnu</li><li>ia64-unknown-linux-gnu</li><li>x86_64-unknown-linux-gnu</li><li>powerpc64-unknown-linux-gnu</li><li>rs6000-ibm-aix5.2.0.0</li><li>sparc-sun-solaris2.8</li><li>i386-unknown-nt4.0 (MS Visual Studio 2005)</li></ul></div><p>

Our build system attempts to use native system compilers where appropriate.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2477605"></a>System Requirements</h2></div></div></div><p>
Here we list the third party tools that MRNet uses and needs for
proper installation on UNIX/Linux systems. For Windows systems,
pre-compiled libraries and binaries are available (upon request).

</p><div class="itemizedlist"><ul type="disc"><li>GNU make</li><li>flex</li><li>bison (version 2.3 or later)</li></ul></div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2476169"></a>Build Configuration</h2></div></div></div><p>
MRNet uses <span class="application">GNU autoconf</span> to discover the
platform specific configuration parameters. The script that does
this auto-configuration is called <span class="command"><strong>configure</strong></span>.
</p><pre class="screen">
<code class="prompt">UNIX&gt;</code>  <span class="command"><strong>./configure --help</strong></span>
</pre><p>
shows all possible options of the command. Below, we display the
MRNet-specific ones:

</p><pre class="screen">
<code class="computeroutput">
  --with-libfldir dir            Directory containing flex library
</code>
<code class="computeroutput">
  --enable-shared                Build shared library versions of MRNet and XPlat
</code>
<code class="computeroutput">
  --enable-debug                 Build MRNet and XPlat with debug information
</code>
<code class="computeroutput">
  --enable-verbosebuild          Show build actions (useful for debugging build problems)
</code>
</pre><p>

<span class="command"><strong>./configure</strong></span> without any options should give reasonable
results, but the user may specify certain options. For example,
</p><pre class="screen">
<code class="prompt">UNIX&gt;</code> <span class="command"><strong>./configure CXX=g++ --with-libfldir=/usr/local/lib</strong></span>
</pre><p>

instructs the configure script to use <span class="command"><strong>g++</strong></span> for the C++
compiler and <code class="filename">/usr/local/lib</code> 
as the location of the flex library.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2476286"></a>Compilation and Installation</h2></div></div></div><p>
To build MRNet:
</p><pre class="screen">
<code class="prompt">UNIX&gt;</code>  <span class="command"><strong>make</strong></span>
</pre><p>
After a successful build, the following files will be present:
</p><div class="itemizedlist"><ul type="disc"><li><code class="filename">$MRNET_ROOT/lib/$MRNET_ARCH/libmrnet.a</code>: MRNet
API library</li><li><code class="filename">$MRNET_ROOT/lib/$MRNET_ARCH/libxplat.a</code>: A library that exports platform dependent routines to MRNet</li><li><code class="filename">$MRNET_ROOT/bin/$MRNET_ARCH/mrnet_commnode</code>: MRNet
internal communcation node</li><li><code class="filename">$MRNET_ROOT/bin/$MRNET_ARCH/mrnet_topgen</code>: MRNet
topology file generator</li></ul></div><p>

To build the MRNet tests:
</p><pre class="screen">
<code class="prompt">UNIX&gt;</code>  <span class="command"><strong>make tests</strong></span>
</pre><p>
builds the MRNet test files. In addition to those files above, you will also generate:
</p><div class="itemizedlist"><ul type="disc"><li><code class="filename">$MRNET_ROOT/bin/$MRNET_ARCH/*_[FE,BE]</code>: MRNet test front-end and back-end programs</li><li><code class="filename">$MRNET_ROOT/bin/$MRNET_ARCH/mrnet_tests.sh</code>: A shell script that runs the test programs and checks for errors in an automated fashion.</li><li><code class="filename">$MRNET_ROOT/lib/$MRNET_ARCH/test_DynamicFilters.so</code>: Shared object used in tests of dynamic filter loading.</li></ul></div><p>

To install the MRNet components (i.e., libraries, executables, and headers) to the 
directories specified during configure (default install locations are 
<code class="filename">/usr/local/{bin,lib,include}</code>):
</p><pre class="screen">
<code class="prompt">UNIX&gt;</code>  <span class="command"><strong>make install</strong></span>
</pre><p>

To install the MRNet tests:
</p><pre class="screen">
<code class="prompt">UNIX&gt;</code>  <span class="command"><strong>make install-tests</strong></span>
</pre><p>

If your system does not provide the C++ Boost headers (normally 
installed in <code class="filename">/usr/include/boost</code>), we provide the subset
of Boost header files necessary for building MRNet. To install these headers:
</p><pre class="screen">
<code class="prompt">UNIX&gt;</code>  <span class="command"><strong>make install-boost</strong></span>
</pre><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2523875"></a>Testing the Code</h2></div></div></div>
The shell script, <span class="application">mrnet_tests.sh</span> is placed in the
binary directory with the other executables during the building of the MRNet
tests as described above. This script can be used to run the MRNet test
programs and check their output for errors. The script is used as follows:
<pre class="screen">
<code class="prompt">UNIX&gt;</code> <span class="command"><strong>mrnet_tests.sh [ -l | -r &lt;hostfile&gt; | -a &lt;hostfile&gt; ] [ -f &lt;sharedobject&gt; ]</strong></span>
</pre></div>
The <code class="option">-l</code> flag is used to run all tests using only topologies that create processes on the local machine. The <code class="option">-r</code> flag runs tests using remote machines specified in the file whose name immediately follows this flag. To run test both locally and remotely, use the <code class="option">-a</code> flag and specify a hostfile to use. To run the programs that test MRNet's ability to dynamically load filters, you must specify the absolute location of the shared object <code class="filename">test_DynamicFilters.so</code> produced when the tests were built.

<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>To successfully run all tests, the location of the MRNet binaries must be in the user's <code class="envar">$PATH</code>. For testing dynamic filters, the filesystem containing the shared object must be available to all the host machines participating in the test.</div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2523942"></a>Bugs, Questions and Comments</h2></div></div></div><p>
MRNet is maintained primarily by the Paradyn Project, University of Wisconsin-Madison.
Comments and feedback whether positive or negative are encouraged.
</p><p>
Please report bugs to paradyn@cs.wisc.edu.
</p><p>
The MRNet webpage is http://www.paradyn.org/mrnet/
</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="id2476136"></a>Chapter 3. MRNet Components and Abstractions</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id2476082">End-Points</a></span></dt><dt><span class="sect1"><a href="#id2476096">Communicators</a></span></dt><dt><span class="sect1"><a href="#id2524651">Streams</a></span></dt><dt><span class="sect1"><a href="#id2524676">Filters</a></span></dt></dl></div><p>
The MRNet distribution has two main components: <code class="filename">libmrnet.a</code>, a
library that is linked into a tool's front-end and back-end components, and
<code class="filename">mrnet_commnode</code>, a program that runs on intermediate nodes
interposed between the application front-end and back-ends. <code class="filename">libmrnet.a
</code> exports an API (See <a class="xref" href="#mrnet_api" title="Chapter 5. The MRNet C++ API Reference">Chapter 5, <i>The MRNet C++ API Reference</i></a>) that enables
I/O interaction between the front-end and groups of back-ends via MRNet. The
primary purpose of <code class="filename">mrnet_commnode</code> is to distribute data
processing functionality across multiple computer hosts and to implement
efficient and scalable group communications. The following sub-sections describe
the lower-level components of the MRNet API in more detail.
</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2476082"></a>End-Points</h2></div></div></div><p>
An MRNet end-point represents a tool or application process. In particular, 
they represent the back-end processes (i.e., leaf processes) in the tree
overlay. The front-end can communicate in a unicast or multicast fashion 
with one or more of these end-points as described below.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2476096"></a>Communicators</h2></div></div></div><p>
MRNet uses communicators to represent groups of end-points. Like
communicators in MPI, MRNet communicators provide a handle that identifies a
set of end-points for point-to-point, multicast or broadcast communications. MPI
applications typically have a non-hierarchical layout of potentially identical
processes. In contrast, MRNet enforces a tree-like layout of all processes,
rooted at the front-end. Accordingly, MRNet communicators are created and
managed by the front-end, and communication is only allowed between a
front-end and its back-ends. As such, back-ends cannot interact with each other
directly using the MRNet API.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2524651"></a>Streams</h2></div></div></div><p>
A stream is a logical channel that connects the front-end to the end-points of a
communicator. All MRNet communication uses the stream abstraction.
Streams carry data packets downstream, from the front-end toward the back-ends,
and upstream, from the back-ends toward the front-end. Streams are
expected to carry data of a specific type, allowing data aggregation operations
to be associated with a stream. The type is specified using a format string
(See <a class="xref" href="#format_strings" title="Appendix A. MRNet Format Strings">Appendix A, <i>MRNet Format Strings</i></a>) similar to those used in C
formatted I/O primitives (e.g., a packet whose data is described by the format
string "%d %d %f %s" contains two integers followed by a float then a character
string). MRNet expands the standard format string specification to allow for 
description of arrays. 
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2524676"></a>Filters</h2></div></div></div><p>
Data aggregation is the process of merging multiple input data packets and
transforming them into one or more output packets. Though it is not necessary
for the aggregation to result in less or even different data, aggregations that
reduce or modify data values are most common. MRNet uses data filters to
aggregate data packets. Filters specify an operation to perform and the type of
the data expected on the bound stream. Filter instances are bound to a stream
at stream creation. MRNet uses two types of filters: synchronization filters
and transformation filters. Synchronization filters organize data packets from
downstream nodes into synchronized waves of data packets, while transformation
filters operate on the synchronized data packets yielding one or more output
packets. A distinction between synchronization and transformation 
filters is that synchronization filters are independent of the packet data type, 
but transformation filters operate on packets of a specific type.
</p><p>
Synchronization filters operate on data flowing upstream in the network,
receiving packets one at a time and outputting packets only when the
specified synchronization criteria has been met.
Synchronization filters provide a mechanism to deal with the asynchronous 
arrival of packets from children nodes. The synchronizer collects packets and
typically aligns them into waves, passing an entire wave onward at the same
time. Therefore, synchronization filters do no data transformation and can
operate on packets in a type-independent fashion. MRNet currently supports
two synchronization modes:
</p><div class="itemizedlist"><ul type="disc"><li><span class="emphasis"><em>Wait For All</em></span>: wait for a packet from every
child node (SFILTER_WAITFORALL)</li><li><span class="emphasis"><em>Do Not Wait</em></span>: output packets immediately (SFILTER_DONTWAIT)</li></ul></div><p>
</p><p>
Transformation filters can be used on both upstream and downstream data flows. 
Transformation filters input a group of synchronized packets, and
combine data from multiple packets by performing an
aggregation that yields one or more new data packets. Since transformation
filters are expected to perform computational operations on data packets,
there is a type requirement for the data packets to be passed to this type of
filter: the data format string of the stream's packets and the filter must be
the same. Transformation operations must be synchronous, but are able to 
maintain state from one execution to the next. MRNet provides several 
transformation filters that should be of general use:
</p><div class="itemizedlist"><ul type="disc"><li><span class="emphasis"><em>Basic scalar operations on characters/integers/floats</em></span>: minimum (TFILTER_MIN), maximum (TFILTER_MAX), summation (TFILTER_SUM), average (TFILTER_AVG)</li><li><span class="emphasis"><em>Concatenation</em></span>: operation that inputs n scalars
and outputs a vector of length n of the same base type (TFILTER_ARRAY_CONCAT)</li></ul></div><p>
<a class="xref" href="#adding_filters" title="Chapter 7. Adding New Filters">Chapter 7, <i>Adding New Filters</i></a> describes facilities for adding new
user-defined transformation and synchronization filters.
</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="simple_example"></a>Chapter 4. A Simple Example</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id2524487">The MRNet Interface</a></span></dt><dt><span class="sect1"><a href="#mrnet_instantiation">MRNet Instantiation</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2524487"></a>The MRNet Interface</h2></div></div></div><p>
A complete description of the MRNet API is in <a class="xref" href="#mrnet_api" title="Chapter 5. The MRNet C++ API Reference">Chapter 5, <i>The MRNet C++ API Reference</i></a>. This section offers a brief overview only.
Using <code class="filename">libmrnet.a</code>, a tool can leverage a system of internal
processes, instances of the <code class="filename">mrnet_commnode</code> program, as a
communication substrate. After instantiation of the MRNet network (discussed in
<a class="xref" href="#mrnet_instantiation" title="MRNet Instantiation">the section called &#8220;MRNet Instantiation&#8221;</a>, the front-end and back-end
processes are connected by the internal processes. The connection topology and
host assignment of these processes is determined by a configuration file, thus
the
geometry of MRNet's process tree can be customized to suit the physical topology
of the underlying hardware resources. While MRNet can generate a variety of
standard topologies, users can easily specify their own topologies; see <a class="xref" href="#mrnet_topology_configuration" title="Chapter 6. MRNET Process-tree Topologies">Chapter 6, <i>MRNET Process-tree
Topologies</i></a> for further discussion.
</p><p>
The MRNet API contains Network, EndPoint, Communicator,
and Stream objects that a tool's front-end and back-end use for communication.
The Network object is used to instantiate the MRNet network and access EndPoint
objects that represent available tool back-ends. The Communicator object is a
container for groups of end-points, and Stream objects are used to send data 
to the EndPoints in a Communicator.
</p><div class="example"><a name="fe_code"></a><p class="title"><b>Example 4.1. MRNet Front-end Sample Code</b></p><div class="example-contents"><pre class="programlisting">
   front_end_main(...) {
1.     Network * net;
2.     Communicator * comm;
3.     Stream * stream;
4.     PacketPtr packet;
5.     int tag = FirstApplicationTag;
6.     float result;

7.     net = new Network(topology_file, backend_exe, backend_argv);

8.     comm = net-&gt;get_BroadcastCommunicator( );

9.     stream = net-&gt;new_Stream(comm, TFILTER_SUM, SFILTER_WAITFORALL);

10.    stream-&gt;send(tag, "%d", SUM_INIT);

11.    stream-&gt;recv(&amp;tag, packet)

12.    packet-&gt;unpack("%f", &amp;result);
   }
</pre></div></div><br class="example-break"><p>
A simplified version of code from an example tool front-end is shown in
<a class="xref" href="#fe_code" title="Example 4.1. MRNet Front-end Sample Code">Example 4.1, &#8220;MRNet Front-end Sample Code&#8221;</a>. In the front-end code, after some variable
definitions in lines 1-6, an instance of the MRNet network is created
on line 7 using the topology specified in topology_file. In line 8, the newly created
Network object is queried for an auto-generated broadcast communicator that
contains all available end-points. In line 9, this Communicator is used to
establish a Stream that will use a built-in filter that finds the summation 
of the data sent upstream. The front-end then
sends one or more initialization messages to the backends; in our example
code on line 10, we broadcast an integer initializer on the new stream. 
The tag parameter is an application-specific value denoting the nature of the message being 
transmitted. After the send operation, the front-end performs a blocking stream receive
at line 11. This call returns a tag and a packet. Finally, line 12 calls unpack to 
deserialize the floating point value contained in packet.
</p><div class="example"><a name="be_code"></a><p class="title"><b>Example 4.2. MRNet Back-end Sample Code</b></p><div class="example-contents"><pre class="programlisting">
   back_end_main(int argc, char** argv) {
1.     Stream * stream;
2.     PacketPtr packet;
3.     int val, tag;
4.     float random_float = (float) random( );

5.     Network * net = new Network(argc,argv);

6.     net-&gt;recv(&amp;tag, packet, &amp;stream);

7.     packet-&gt;unpack("%d", &amp;val );

8.     if( val == SUM_INIT )
9.         stream-&gt;send(tag, "%f", random_float);
   }
</pre></div></div><br class="example-break"><p>
<a class="xref" href="#be_code" title="Example 4.2. MRNet Back-end Sample Code">Example 4.2, &#8220;MRNet Back-end Sample Code&#8221;</a> shows the code for the back-end that 
reciprocates the actions of the front-end. Each tool back-end
first connects to the MRNet network in line 5, using the back-end version 
of the Network constructor that receives its 
arguments via the program argument vector (argc/argv). While the front-end makes 
a stream-specific receive call, the back-ends use a stream-anonymous network receive 
that returns the tag sent by the front-end, the packet containing the actual data 
sent, and a stream object representing the stream that the front-end has established. 
Finally, each back-end sends a scalar floating point value upstream toward the front-end.
</p><p>
A complete example of MRNet code can be found below in <a class="xref" href="#example" title="Appendix C. A Complete MRNet Example: Integer Addition">Appendix C, <i>A Complete MRNet Example: Integer Addition</i></a>.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mrnet_instantiation"></a>MRNet Instantiation</h2></div></div></div><p>
While conceptually simple, creating and connecting the internal processes is
complicated by interactions with the various job scheduling systems. In the
simplest environments, we can launch jobs manually using facilities like rsh
or ssh. In more complex environments, it is necessary to submit all requests
to a job management system. In this case, we are constrained by the operations
provided by the job manager (and these vary from system to system). We
currently support two modes of instantiating MRNet-based tools.
</p><p>
In the first mode of process instantiation, MRNet creates the internal and
back-end processes, using the specified MRNet topology configuration to
determine the hosts on which the components should be located. First, the
front-end consults the configuration and uses a remote shell program
to create internal processes for the first level of the communication tree 
on the appropriate hosts. Upon instantiation, the newly created processes 
establish a network connection to the process that created it. The first 
activity on this connection is a message from parent to child containing the 
portion of the configuration relevant to that child. The child then uses this 
information to begin instantiation of the sub-tree rooted at that child. When 
a sub-tree has been established, the root of that sub-tree sends a report to 
its parent containing the end-points accessible via that sub-tree. Each 
internal node establishes its children processes and their respective connections
sequentially. However, since the various processes are expected to run on
different compute nodes, sub-trees in different branches of the network are
created concurrently, maximizing the efficiency of network instantiation.
</p><p>
In the second mode of process instantiation, MRNet relies on a process
management system to create some or all of the MRNet processes. This mode
accommodates tools that require their back-ends to create, monitor, and
control other processes. For example, IBM's POE uses environment
variables to pass information, such as the process' rank within the
application's global MPI communicator, to the MPI run-time library in each
application process. In cases like this, MRNet cannot provide back-end
processes with the environment necessary to start MPI application processes.
As a result, MRNet creates its internal processes recursively as in the first
instantiation mode, but does not instantiate any back-end processes. MRNet
then waits for the tool back-ends to be started by the process management 
system to ensure they have the environment needed to create application processes 
successfully. To allow back-ends to connect to the MRNet network, information
such as process host names and connection port numbers must be provided to the 
back-ends. This information can be provided via the environment, using shared 
filesystems or other information services as available on the target system. 
To collect the necessary information, the front-end can use the MRNet API methods 
for discovering the network topology details. We show how to construct a tool
that requires back-ends to be separately instantiated in 
<code class="filename">$MRNET_ROOT/Examples/NoBackEndInstantiation</code>.
</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="mrnet_api"></a>Chapter 5. The MRNet C++ API Reference</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#sect:network_api">Class Network</a></span></dt><dt><span class="sect1"><a href="#sect:net_topol_api">Class NetworkTopology</a></span></dt><dt><span class="sect1"><a href="#sect:comm_api">Class Communicator</a></span></dt><dt><span class="sect1"><a href="#sect:stream_api">Class Stream</a></span></dt><dt><span class="sect1"><a href="#sect:packet_api">Class Packet</a></span></dt></dl></div><p>
All classes are included in the <code class="varname">MRN</code> namespace.
For this discussion, we do not explicitly include reference to the
namespace; for example, when we reference the class <code class="classname">Network</code>, we are
implying the class <code class="classname">MRN::Network</code>.
</p><p>
In MRNet, there are five top-level classes: <code class="classname">Network</code>,
<code class="classname">NetworkTopology</code>, <code class="classname">Communicator</code>,
<code class="classname">Stream</code>, and <code class="classname">Packet</code>.
The Network class primarily contains methods for instantiating and destroying MRNet
process trees. The NetworkTopology class represents
the interface for discovering details about the topology of an instantiated Network.
Application back-ends are referred to as end-points, and the Communicator
class is used to reference a group of end-points. A Communicator is used to 
establish a Stream for unicast, multicast, or broadcast communications 
via the MRNet infrastructure. The Packet class encapsulates the data packets 
that are sent on a Stream. The public members of these classes are detailed below.
</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sect:network_api"></a>Class Network</h2></div></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">Network::Network</b>(</code></td><td><var class="pdparam">topology</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">backend_exe</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">backend_argv</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">rank_backends</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">using_memory_buffer</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>const char * </code> </td><td><code><var class="pdparam">topology</var>;</code></td></tr><tr><td><code>const char * </code> </td><td><code><var class="pdparam">backend_exe</var>;</code></td></tr><tr><td><code>const char ** </code> </td><td><code><var class="pdparam">backend_argv</var>;</code></td></tr><tr><td><code>bool </code> </td><td><code><var class="pdparam">rank_backends</var>;</code></td></tr><tr><td><code>bool </code> </td><td><code><var class="pdparam">using_memory_buffer</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><p>
The front-end constructor method that is used
to instantiate the MRNet process tree. <code class="varname">topology</code> is
the path to a configuration file that describes the desired process tree
topology. 
</p><p>
<code class="varname">backend_exe</code> is the path to the executable to be
used for the application's back-end processes. <code class="varname">backend_argv</code> 
is a null terminated list of arguments to pass to the back-end application upon 
creation. If <code class="varname">backend_exe</code>
is NULL, no back-end processes will be started, and the leaves of the topology
specified by <code class="varname">topology</code> will be instances of <code class="filename">mrnet_commnode</code>. 
</p><p>
<code class="varname">rank_backends</code> indicates whether the back-end
process ranks should begin at 0, similar to MPI rank numbering, and defaults to true. 
</p><p>
If <code class="varname">using_memory_buffer</code> is set to true (default is false), 
the <code class="varname">topology</code> parameter is actually a pointer to a memory buffer 
containing the topology specification, rather than the name of a file. 
</p><p>
When this function completes without error, 
all MRNet processes specified in the topology will have been instantiated. You may
use <code class="function">Network::has_error()</code> to check for successful completion.
</p></blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">Network::Network</b>(</code></td><td><var class="pdparam">argc</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">argv</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>int </code> </td><td><code><var class="pdparam">argc</var>;</code></td></tr><tr><td><code>char ** </code> </td><td><code><var class="pdparam">argv</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote">
The back-end constructor method that is used when the process is started due to a 
front-end Network instantiation. MRNet automatically passes the necessary 
information to the process using the program argument vector 
(<code class="varname">argc/argv</code>) by inserting it after the user-specified arguments. 
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">Network::Network</b>(</code></td><td><var class="pdparam">parent_hostname</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">parent_port</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">parent_rank</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">my_hostname</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">my_rank</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>const char * </code> </td><td><code><var class="pdparam">parent_hostname</var>;</code></td></tr><tr><td><code>Port </code> </td><td><code><var class="pdparam">parent_port</var>;</code></td></tr><tr><td><code>Rank </code> </td><td><code><var class="pdparam">parent_rank</var>;</code></td></tr><tr><td><code>const char * </code> </td><td><code><var class="pdparam">my_hostname</var>;</code></td></tr><tr><td><code>Rank </code> </td><td><code><var class="pdparam">my_rank</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><p>The back-end constructor method that is used to attach to an instantiated MRNet process tree,
as is necessary when the back-end processes are not started as part of a front-end Network
instantiation.
</p><p>
<code class="varname">parent_hostname</code> is the name of the host where the parent
process is running. <code class="varname">parent_port</code> and <code class="varname">parent_rank</code> are the 
port number and rank of the parent process, respectively.
Information about the tree processes
to which back-ends should connect can be gathered by the front-end using the NetworkTopology
object returned from <code class="function">Network::get_NetworkTopology</code>. 
</p><p>
<code class="varname">my_hostname</code> is the name of the host on which the back-end process is running,
and <code class="varname">my_rank</code> is an arbitrary rank chosen by the back-end to not conflict with
the ranks of existing tree processes.
</p></blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">Network::~Network</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote"><code class="function">Network::~Network</code> is used to tear down the
MRNet process tree and clean up the Network object. The first action
taken by the destructor is to invoke <code class="function">Network::shutdown_Network</code>.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">Network::shutdown_Network</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote"><code class="function">Network::shutdown_Network</code> is used to tear down the
MRNet process tree. When this function is called, each node in the
tree sends a control message to its immediate children
informing them of the "shutdown network" request, and waits for confirmation. 
If the node is an internal process (i.e., mrnet_commnode), the process will then terminate.
If the node is an application back-end, the process will terminate unless
a separate call to <code class="function">Network::set_TerminateBackEndsOnShutdown</code>
has been made to request otherwise.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">Network::set_TerminateBackEndsOnShutdown</b>(</code></td><td><var class="pdparam">terminate</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>bool </code> </td><td><code><var class="pdparam">terminate</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><code class="function">Network::set_TerminateBackEndsOnShutdown</code> is used to
control whether application back-end processes are terminated when the MRNet
Network is shutdown. By default, back-end processes will be terminated. If this
behavior is not desired, call this method with <code class="varname">terminate</code> set to false.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">bool <b class="fsfunc">Network::has_error</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote"><code class="function">Network::has_error</code> returns true if an error has
occured during the last call to a <code class="classname">Network</code> method. 
<code class="function">Network::print_error</code>
can be used to print a message describing the exact error. 
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">Network::print_error</b>(</code></td><td><var class="pdparam">error_msg</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>const char * </code> </td><td><code><var class="pdparam">error_msg</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><code class="function">Network::print_error</code> prints a message to stderr
describing the last error encountered during a <code class="classname">Network</code>
 method. It first prints the null-terminated string, <code class="varname">error_msg</code>
followed by a colon then the actual error message followed by a newline.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">std::string <b class="fsfunc">Network::get_LocalHostName</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote"><code class="function">Network::get_LocalHostName</code> returns the name of the host
on which the MRNet process is running.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">Port <b class="fsfunc">Network::get_LocalPort</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote"><code class="function">Network::get_LocalPort</code> returns the port at which the 
MRNet process can be contacted.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">Rank <b class="fsfunc">Network::get_LocalRank</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote"><code class="function">Network::get_LocalRank</code> returns the rank of the
MRNet process.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">int <b class="fsfunc">Network::load_FilterFunc</b>(</code></td><td><var class="pdparam">so_file</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">func_name</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">is_transformation_filter</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>const char * </code> </td><td><code><var class="pdparam">so_file</var>;</code></td></tr><tr><td><code>const char * </code> </td><td><code><var class="pdparam">func_name</var>;</code></td></tr><tr><td><code>bool </code> </td><td><code><var class="pdparam">is_transformation_filter</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><p>
This method, used for loading new filter operations into the Network
is conveniently similar to the conventional <code class="function">dlopen()
</code> facilities for opening a shared object and dynamically
loading symbols defined within. 
</p><p>
<code class="varname">so_file</code> is the path to a shared object file that contains
the filter function to be loaded and <code class="varname">func_name</code> is the name of the
function to be loaded. The last parameter <code class="varname">is_transformation_filter
</code> defaults to true and can usually be omitted since the common case
is to load transformation, not synchronization, filters.
</p><p>
On success, <code class="function">Network::load_FilterFunc</code> returns the id
of the newly loaded filter which may be used in subsequent calls to
<code class="function">Network::new_Stream</code>. A value of -1 is returned
on failure.
</p></blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">int <b class="fsfunc">Network::recv</b>(</code></td><td><var class="pdparam">tag</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">packet</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">stream</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">blocking</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>int * </code> </td><td><code><var class="pdparam">tag</var>;</code></td></tr><tr><td><code>PacketPtr &amp; </code> </td><td><code><var class="pdparam">packet</var>;</code></td></tr><tr><td><code>Stream ** </code> </td><td><code><var class="pdparam">stream</var>;</code></td></tr><tr><td><code>bool </code> </td><td><code><var class="pdparam">blocking</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><p>
<code class="function">Network::recv</code> is used to invoke a stream-anonymous
receive operation. Any packet available (addressed to any stream)
will be returned (in roughly FIFO ordering) via the output parameters. 
</p><p>
<code class="varname">otag</code> will be filled in with the integer
tag value that was passed by the corresponding <code class="function">Stream::send()
</code> operation. <code class="varname">packet</code> is the packet that was
received. A pointer to the Stream to which the packet was addressed
will be returned in <code class="varname">stream</code>. 
</p><p>
<code class="varname">blocking</code>
is used to signal whether this call should block or return if data is not
immediately available; it defaults to a blocking call.
</p><p>
A return value of -1 indicates an error, 0 indicates no packets were 
available, and 1 indicates success.
</p></blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">bool <b class="fsfunc">Network::enable_PerformanceData</b>(</code></td><td><var class="pdparam">metric</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">context</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>perfdata_metric_t </code> </td><td><code><var class="pdparam">metric</var>;</code></td></tr><tr><td><code>perfdata_context_t </code> </td><td><code><var class="pdparam">context</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><code class="function">Network::enable_PerformanceData</code> uses
<code class="function">Stream::enable_PerformanceData</code> to start the recording
of performance data of the specified <code class="varname">metric</code> type for the
given <code class="varname">context</code> on all streams. Returns true on success,
false otherwise.
<a class="xref" href="#perf_data" title="Appendix B. MRNet Stream Performance Data">Appendix B, <i>MRNet Stream Performance Data</i></a> describes the supported metric and context types.
See <code class="function">Stream::enable_PerformanceData</code> for additional details.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">bool <b class="fsfunc">Network::disable_PerformanceData</b>(</code></td><td><var class="pdparam">metric</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">context</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>perfdata_metric_t </code> </td><td><code><var class="pdparam">metric</var>;</code></td></tr><tr><td><code>perfdata_context_t </code> </td><td><code><var class="pdparam">context</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><code class="function">Network::disable_PerformanceData</code> uses
<code class="function">Stream::disable_PerformanceData</code> to stop the recording
of performance data of the specified <code class="varname">metric</code> type for the
given <code class="varname">context</code> on all streams. Returns true on success,
false otherwise. See 
<code class="function">Stream::disable_PerformanceData</code> for additional details.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">bool <b class="fsfunc">Network::collect_PerformanceData</b>(</code></td><td><var class="pdparam">results</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">metric</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">context</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">aggr_filter_id</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>std::map&lt; int, rank_perfdata_map &gt; &amp; </code> </td><td><code><var class="pdparam">results</var>;</code></td></tr><tr><td><code>perfdata_metric_t </code> </td><td><code><var class="pdparam">metric</var>;</code></td></tr><tr><td><code>perfdata_context_t </code> </td><td><code><var class="pdparam">context</var>;</code></td></tr><tr><td><code>int </code> </td><td><code><var class="pdparam">aggr_filter_id</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><code class="function">Network::collect_PerformanceData</code> uses
<code class="function">Stream::collect_PerformanceData</code> to collect the 
performance data of the specified <code class="varname">metric</code> type for the
given <code class="varname">context</code> on all streams. The performance data of 
each stream is passed through the transformation filter identified by 
<code class="varname">aggr_filter_id</code>. The data for all streams is stored within
the map <code class="varname">results</code>, keyed by stream identifier. Returns true on success,
false otherwise.
See <code class="function">Stream::collect_PerformanceData</code> for additional details.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">Network::print_PerformanceData</b>(</code></td><td><var class="pdparam">metric</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">context</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>perfdata_metric_t </code> </td><td><code><var class="pdparam">metric</var>;</code></td></tr><tr><td><code>perfdata_context_t </code> </td><td><code><var class="pdparam">context</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><code class="function">Network::enable_PerformanceData</code> uses
<code class="function">Stream::print_PerformanceData</code> to print recorded
performance data of the specified <code class="varname">metric</code> type for the
given <code class="varname">context</code> on all streams. Data is printed to the
MRNet log files. See <code class="function">Stream::print_PerformanceData</code> 
for additional details.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">Network::get_EventNotificationFd</b>(</code></td><td><var class="pdparam">etyp</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>EventType </code> </td><td><code><var class="pdparam">etyp</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><p><code class="function">Network::get_EventNotificationFd</code> returns a file descriptor
that can be added to the <code class="literal">read fd_set</code> of  <code class="function">select()</code> 
to receive notification of interesting DATA, TOPOLOGY, or ERROR events.
</p><p>
<code class="varname">etyp</code> should be set to one of <code class="literal">ERROR_EVENT</code>, 
<code class="literal">DATA_EVENT</code>, or <code class="literal">TOPOLOGY_EVENT</code>.
<code class="literal">DATA_EVENT</code> can be used by both front-end and back-end
processes to provide notification that one or more data packets have been received. 
<code class="literal">TOPOLOGY_EVENT</code> and <code class="literal">ERROR_EVENT</code> can only be used
by front-end processes, and provide notification when the front-end observes a change in 
<code class="classname">NetworkTopology</code> or an error, respectively.</p><p> When <code class="function">select()</code> indicates that the file descriptor has data 
available, you should call <code class="function">Network::clear_EventNotificationFd</code> before
taking action on the notification. When notifications are no longer needed, use
<code class="function">Network::close_EventNotificationFd</code></p></blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">Network::clear_EventNotificationFd</b>(</code></td><td><var class="pdparam">etyp</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>EventType </code> </td><td><code><var class="pdparam">etyp</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method resets the event notification
file descriptor returned from <code class="function">Network::get_EventNotificationFd</code>.
<code class="varname">etyp</code> should be set to one of <code class="literal">ERROR_EVENT</code>, 
<code class="literal">DATA_EVENT</code>, or <code class="literal">TOPOLOGY_EVENT</code>.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">Network::close_EventNotificationFd</b>(</code></td><td><var class="pdparam">etyp</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>EventType </code> </td><td><code><var class="pdparam">etyp</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method closes the event notification
file descriptor returned from <code class="function">Network::get_EventNotificationFd</code>.
<code class="varname">etyp</code> should be set to one of <code class="literal">ERROR_EVENT</code>, 
<code class="literal">DATA_EVENT</code>, or <code class="literal">TOPOLOGY_EVENT</code>.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">Network::get_DataSocketFds</b>(</code></td><td><var class="pdparam">fd_array</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">fd_array_size</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>int ** </code> </td><td><code><var class="pdparam">fd_array</var>;</code></td></tr><tr><td><code>unsigned int * </code> </td><td><code><var class="pdparam">fd_array_size</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><code class="function">Network::get_DataSocketFds</code> is deprecated and has been removed.
See <code class="function">Network::get_EventNotificationFd</code> for a description of
how to receive notifications for <code class="literal">DATA_EVENT</code>s.
</blockquote></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sect:net_topol_api"></a>Class NetworkTopology</h2></div></div></div><p>
Instances of NetworkTopology are network specific, so they are created 
when a Network is instantiated. MRNet API users should not need to
create their own NetworkTopology instances.
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">NetworkTopology * <b class="fsfunc">Network::get_NetworkTopology</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote"><code class="function">Network::get_NetworkTopology</code> is used to retrieve 
a pointer to the underlying NetworkTopology instance of a Network.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">unsigned int <b class="fsfunc">NetworkTopology::get_NumNodes</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns the total number of nodes in the tree topology, 
including front-end, internal, and back-end processes.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">NetworkTopology::Node * <b class="fsfunc">NetworkTopology::find_Node</b>(</code></td><td><var class="pdparam">node_rank</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>Rank </code> </td><td><code><var class="pdparam">node_rank</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns a pointer to the tree node with rank equal to <code class="varname">node_rank</code>,
or NULL if not found.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">NetworkTopology::Node * <b class="fsfunc">NetworkTopology::get_Root</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns a pointer to the root node of the tree,
or NULL if not found.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">NetworkTopology::get_Leaves</b>(</code></td><td><var class="pdparam">leaves</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>std::vector&lt; NetworkTopology::Node * &gt; &amp; </code> </td><td><code><var class="pdparam">leaves</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method fills in the <code class="varname">leaves</code> vector with pointers to the
leaf nodes in the topology. In the case where back-end processes are not
started when the Network is instantiated, a front-end process can use this 
function to retrieve information about the leaf internal processes to which
the back-ends should attach.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">NetworkTopology::get_BackEndNodes</b>(</code></td><td><var class="pdparam">nodes</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>std::set&lt; NetworkTopology::Node * &gt; &amp; </code> </td><td><code><var class="pdparam">nodes</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method fills a set with pointers to all back-end process tree nodes.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">NetworkTopology::get_ParentNodes</b>(</code></td><td><var class="pdparam">nodes</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>std::set&lt; NetworkTopology::Node * &gt; &amp; </code> </td><td><code><var class="pdparam">nodes</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method fills a set with pointers to all tree nodes that are parents
(i.e., those nodes having at least one child).
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">NetworkTopology::get_OrphanNodes</b>(</code></td><td><var class="pdparam">nodes</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>std::set&lt; NetworkTopology::Node * &gt; &amp; </code> </td><td><code><var class="pdparam">nodes</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method fills a set with pointers to all tree nodes that have
no parent due to a failure.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">NetworkTopology::get_TreeStatistics</b>(</code></td><td><var class="pdparam">num_nodes</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">depth</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">min_fanout</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">max_fanout</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">avg_fanout</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">stddev_fanout</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>unsigned int &amp; </code> </td><td><code><var class="pdparam">num_nodes</var>;</code></td></tr><tr><td><code>unsigned int &amp; </code> </td><td><code><var class="pdparam">depth</var>;</code></td></tr><tr><td><code>unsigned int &amp; </code> </td><td><code><var class="pdparam">min_fanout</var>;</code></td></tr><tr><td><code>unsigned int &amp; </code> </td><td><code><var class="pdparam">max_fanout</var>;</code></td></tr><tr><td><code>double &amp; </code> </td><td><code><var class="pdparam">avg_fanout</var>;</code></td></tr><tr><td><code>double &amp; </code> </td><td><code><var class="pdparam">stddev_fanout</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><p>
This method provides users statistics about the tree topology by filling
the supplied parameters.
</p><p>
<code class="varname">num_nodes</code>
is the total number of tree nodes (same as the value returned by 
<code class="function">NetworkTopology::get_NumNodes</code>), <code class="varname">depth</code> is the 
depth of the tree (i.e., the maximum path length from root to any leaf), <code class="varname">min_fanout</code>
is the minimum number of children of any parent node, <code class="varname">max_fanout</code> is the
maximum number of children of any parent node, <code class="varname">avg_fanout</code> is the average
number of children across all parent nodes, and <code class="varname">stddev_fanout</code> is the standard
deviation in number of children across all parent nodes.
</p></blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">NetworkTopology::print_TopologyFile</b>(</code></td><td><var class="pdparam">filename</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>const char * </code> </td><td><code><var class="pdparam">filename</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method will create (or overwrite) the specified topology file 
<code class="varname">filename</code> using the current state of this 
<code class="classname">NetworkTopology</code> object.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">NetworkTopology::print_DOTGraph</b>(</code></td><td><var class="pdparam">filename</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>const char * </code> </td><td><code><var class="pdparam">filename</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method will create (or overwrite) the specified dot graph file 
<code class="varname">filename</code> using the current state of this 
<code class="classname">NetworkTopology</code> object.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">std::string <b class="fsfunc">NetworkTopology::Node::get_HostName</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns a character string identifying the hostname of the tree node.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">Port <b class="fsfunc">NetworkTopology::Node::get_Port</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns the connection port of the tree node.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">Rank <b class="fsfunc">NetworkTopology::Node::get_Rank</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns the unique rank of the tree node.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">const std::set&lt; NetworkTopology::Node * &gt; &amp; <b class="fsfunc">NetworkTopology::Node::get_Children</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns a set containing pointers to the children of the tree node, and is useful
for navigating through the tree.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">unsigned int <b class="fsfunc">NetworkTopology::Node::get_NumChildren</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns the number of children of the tree node.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">unsigned int <b class="fsfunc">NetworkTopology::Node::find_SubTreeHeight</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns the height of the subtree rooted at this tree node.
</blockquote></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sect:comm_api"></a>Class Communicator</h2></div></div></div><p>
Instances of Communicator are network specific, so their creation methods
are functions of an instantiated Network object.
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">Communicator * <b class="fsfunc">Network::new_Communicator</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns a pointer to a new Communicator object. The object
initially contains <span class="emphasis"><em>no</em></span> end-points. Use <code class="function">
Communicator::add_EndPoint</code> to populate the Communicator.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">Communicator * <b class="fsfunc">Network::new_Communicator</b>(</code></td><td><var class="pdparam">comm</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>Communicator &amp; </code> </td><td><code><var class="pdparam">comm</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns a pointer to a new Communicator object that initially
contains the set of end-points contained in <code class="varname">comm</code>.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">Communicator * <b class="fsfunc">Network::new_Communicator</b>(</code></td><td><var class="pdparam">endpoints</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>std::set&lt; CommunicationNode * &gt; &amp; </code> </td><td><code><var class="pdparam">endpoints</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns a pointer to a new Communicator object that initially
contains the set of end-points contained in <code class="varname">endpoints</code>.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">Communicator * <b class="fsfunc">Network::get_BroadcastCommunicator</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote"><p>
This method returns a pointer to a default broadcast Communicator containing all the
end-points available in the system at the time the function is called. </p><p>
Multiple calls to 
this function return the same pointer to the broadcast 
communicator object created at network instantiation. If the Network's topology changes,
as can occur when starting back-ends separately, the object will be updated to reflect
the additions or deletions. This object should not be deleted.</p></blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">bool <b class="fsfunc">Communicator::add_EndPoint</b>(</code></td><td><var class="pdparam">ep_rank</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>Rank </code> </td><td><code><var class="pdparam">ep_rank</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><p>
This method is used to add an existing end-point with rank 
<code class="varname">ep_rank</code> to the set contained
by the Communicator. </p><p>The original set of end-points contained by the
Communicator is tested to see if it already contains the potentially
new end-point. If so, the function silently returns successfully.
This method fails if there exists no end-point defined by
<code class="varname">ep_rank</code>. This method returns true on success, false 
on failure.</p></blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">bool <b class="fsfunc">Communicator::add_EndPoint</b>(</code></td><td><var class="pdparam">endpoint</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>CommunicationNode * </code> </td><td><code><var class="pdparam">endpoint</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method is similar to the <code class="function">add_EndPoint()</code>
above except that it takes a pointer to a CommunicationNode object 
instead of a rank. Success and failure conditions are exactly as stated above. 
This method also returns true on success and false on failure.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">const std::set&lt; CommunicationNode * &gt; &amp; <b class="fsfunc">Communicator::get_EndPoints</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns a reference to the set of CommunicationNode pointers comprising
the end-points in the Communicator.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">std::string <b class="fsfunc">CommunicationNode::get_HostName</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns a character string identifying the hostname of the
end-point represented by this CommunicationNode.
is out of range.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">Port <b class="fsfunc">CommunicationNode::get_Port</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns the connection port of the end-point 
represented by this CommunicationNode.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">Rank <b class="fsfunc">CommunicationNode::get_Rank</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns the unique rank of the end-point 
represented by this CommunicationNode.
</blockquote></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sect:stream_api"></a>Class Stream</h2></div></div></div><p>
Instances of Stream are network specific, so their creation methods
are functions of an instantiated Network object.  There are two common approaches to
creating a new stream.
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">Stream * <b class="fsfunc">Network::new_Stream</b>(</code></td><td><var class="pdparam">comm</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">up_transfilter_id</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">up_syncfilter_id</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">down_transfilter_id</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>Communicator * </code> </td><td><code><var class="pdparam">comm</var>;</code></td></tr><tr><td><code>int </code> </td><td><code><var class="pdparam">up_transfilter_id</var>;</code></td></tr><tr><td><code>int </code> </td><td><code><var class="pdparam">up_syncfilter_id</var>;</code></td></tr><tr><td><code>int </code> </td><td><code><var class="pdparam">down_transfilter_id</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><p>
This version of <code class="function">Network::new_Stream()</code> is the straightforward way to
create a Stream object attached to the end-points specified by a Communicator object 
<code class="varname">comm</code>.
</p><p><code class="varname">up_transfilter_id</code> specifies the
transformation filter to apply to data flowing upstream from the application 
back-ends toward the front-end; the default value is <code class="literal">TFILTER_NULL</code>.
</p><p><code class="varname">up_syncfilter_id</code> specifies the synchronization filter to apply 
to upstream packets; the default value is <code class="literal">SFILTER_WAITFORALL</code>. 
</p><p><code class="varname">down_transfilter_id</code> allows the user to specify a filter to apply 
to downstream data flows; the default value is <code class="literal">TFILTER_NULL</code>.</p></blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">Stream * <b class="fsfunc">Network::new_Stream</b>(</code></td><td><var class="pdparam">comm</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">us_filters</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">sync_filters</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">ds_filters</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>Communicator * </code> </td><td><code><var class="pdparam">comm</var>;</code></td></tr><tr><td><code>std::string </code> </td><td><code><var class="pdparam">us_filters</var>;</code></td></tr><tr><td><code>std::string </code> </td><td><code><var class="pdparam">sync_filters</var>;</code></td></tr><tr><td><code>std::string </code> </td><td><code><var class="pdparam">ds_filters</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><p>
This version of <code class="function">Network::new_Stream()</code> allows the user
to map arbitrary packet filters to arbitrary nodes within the tree.  Strings
are used to express these mappings, with the following syntax: <code class="function">"filter_id_1 =&gt; node_rank_1;
filter_id_2 =&gt; node_rank_2;"</code>.  Like the simpler version of
<code class="function">Network::new_Stream()</code>, the end-points are specified by the
<code class="varname">comm</code> argument.  See HeterogeneousFilters under the Examples directory to see
a <code class="function">Network::new_Stream()</code> call that specifies different filter types to be used
within the same stream.</p><p><code class="varname">us_filters</code> specifies the
transformation filter(s) to apply to data flowing upstream from the application 
back-ends toward the front-end.
</p><p><code class="varname">sync_filters</code> specifies the synchronization filter(s) to apply 
to upstream packets.
</p><p><code class="varname">ds_filters</code> allows the user to specify a filter to apply 
to downstream data flows.</p><p>Note that more than one filter should not be assigned to a single node in any of these strings.</p></blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">Stream * <b class="fsfunc">Network::get_Stream</b>(</code></td><td><var class="pdparam">iid</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>unsigned int </code> </td><td><code><var class="pdparam">iid</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><code class="function">Network::get_Stream()</code> returns a pointer to the Stream 
identified by <code class="varname">id</code>, or NULL on failure.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">unsigned int <b class="fsfunc">Stream::get_Id</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns the integer identifier for this Stream.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">const std::set&lt; Rank &gt; &amp; <b class="fsfunc">Stream::get_EndPoints</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns the set of end-point ranks for this Stream.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">unsigned int <b class="fsfunc">Stream::size</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns an integer indicating the number of end-points for this Stream.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">int <b class="fsfunc">Stream::send</b>(</code></td><td><var class="pdparam">tag</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">format_string</var>, </td><td> </td></tr><tr><td> </td><td>...<code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>int </code> </td><td><code><var class="pdparam">tag</var>;</code></td></tr><tr><td><code>const char * </code> </td><td><code><var class="pdparam">format_string</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method invokes a data send operation on the calling Stream.
<code class="varname">tag</code> is an integer identifier that is expected
to classify the data in the packet to be transmitted across the Stream.
<code class="varname">format_string</code> is a format string describing the data
in the packet (See <a class="xref" href="#format_strings" title="Appendix A. MRNet Format Strings">Appendix A, <i>MRNet Format Strings</i></a>
for a full description.) On success, <code class="function">Stream::send()</code>
returns 0; on failure -1.
<div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><code class="varname">tag</code> must have a value greather than or equal to the
constant <code class="literal">FirstApplicationTag</code> defined by MRNet 
(<code class="filename">#include "mrnet/Types.h"</code>). Tag values less than
<code class="literal">FirstApplicationTag</code> are reserved for internal MRNet use.
</div></blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">int <b class="fsfunc">Stream::recv</b>(</code></td><td><var class="pdparam">tag</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">packet</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">blocking</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>int * </code> </td><td><code><var class="pdparam">tag</var>;</code></td></tr><tr><td><code>PacketPtr &amp; </code> </td><td><code><var class="pdparam">packet</var>;</code></td></tr><tr><td><code>bool </code> </td><td><code><var class="pdparam">blocking</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><p>
<code class="function">Stream::recv()</code> invokes a stream-specific
receive operation. Packets addressed to the calling stream
will be returned in strictly FIFO ordering via the output parameters. 
</p><p>
<code class="varname">tag</code> will be filled in with the integer
tag value that was passed by the corresponding <code class="function">Stream::send()
</code> operation. <code class="varname">packet</code> is the recieved Packet. 
</p><p>
<code class="varname">blocking</code> determines whether the receive should block 
or return if data is not immediately available; it defaults to a blocking call. 
</p><p>
A return value of -1 indicates an error, 0 indicates no packets were 
available, and 1 indicates success.</p></blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">int <b class="fsfunc">Stream::flush</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
Commits a flush of all packets currently buffered by the stream
pending an output operation. A successful return value of 1 
indicates that all packets on the calling stream have been passed 
to the operating system for network transmission.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">int <b class="fsfunc">Stream::set_FilterParameters</b>(</code></td><td><var class="pdparam">upstream</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">format_string</var>, </td><td> </td></tr><tr><td> </td><td>...<code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>bool </code> </td><td><code><var class="pdparam">upstream</var>;</code></td></tr><tr><td><code>const char * </code> </td><td><code><var class="pdparam">format_string</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><p><code class="function">Stream::set_FilterParameters</code> allows users to dynamically
configure the operation of a Stream transformation filter by passing arbitrary data
in a similar fashion to <code class="function">Stream::send</code>. When the filter executes, the
passed data is available as a PacketPtr parameter to the filter, and the
filter can extract the configuration settings. 
</p><p>When set to true, <code class="varname">upstream</code>
indicates the upstream transformation filter should be updated, while a 
value of false will update the downstream transformation filter.</p></blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">bool <b class="fsfunc">Stream::enable_PerformanceData</b>(</code></td><td><var class="pdparam">metric</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">context</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>perfdata_metric_t </code> </td><td><code><var class="pdparam">metric</var>;</code></td></tr><tr><td><code>perfdata_context_t </code> </td><td><code><var class="pdparam">context</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><code class="function">Stream::enable_PerformanceData</code> starts recording
performance data for the specified <code class="varname">metric</code> type for the
given <code class="varname">context</code>.  Returns true on success,
false otherwise. <a class="xref" href="#perf_data" title="Appendix B. MRNet Stream Performance Data">Appendix B, <i>MRNet Stream Performance Data</i></a> describes 
the supported metric and context types.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">bool <b class="fsfunc">Stream::disable_PerformanceData</b>(</code></td><td><var class="pdparam">metric</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">context</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>perfdata_metric_t </code> </td><td><code><var class="pdparam">metric</var>;</code></td></tr><tr><td><code>perfdata_context_t </code> </td><td><code><var class="pdparam">context</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><code class="function">Stream::disable_PerformanceData</code> stops recording
performance data for the specified <code class="varname">metric</code> type for the
given <code class="varname">context</code>. Previously recorded data is not
discarded, so that it can be retrieved with 
<code class="function">Stream::collect_PerformanceData</code>. Users can enable/disable
recording for a particular <code class="varname">metric</code> and 
<code class="varname">context</code> any number of times before collecting the results. 
Returns true on success, false otherwise.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">bool <b class="fsfunc">Stream::collect_PerformanceData</b>(</code></td><td><var class="pdparam">results</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">metric</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">context</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">aggr_filter_id</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>rank_perfdata_map&amp; </code> </td><td><code><var class="pdparam">results</var>;</code></td></tr><tr><td><code>perfdata_metric_t </code> </td><td><code><var class="pdparam">metric</var>;</code></td></tr><tr><td><code>perfdata_context_t </code> </td><td><code><var class="pdparam">context</var>;</code></td></tr><tr><td><code>int </code> </td><td><code><var class="pdparam">aggr_filter_id</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><p><code class="function">Stream::collect_PerformanceData</code> collects the recorded
performance data for the specified <code class="varname">metric</code> type for the
given <code class="varname">context</code>. The collected data is stored within a
<code class="varname">rank_perfdata_map</code>, which associates individual Ranks to a 
<code class="varname">std::vector&lt; perf_data_t &gt;</code> containing the recorded
data instances. After collection, the recorded data at each Rank is discarded. 
Returns true on success, false otherwise.</p><p>Users can aggregate the recorded data across Ranks by specifying a 
transformation filter with <code class="varname">aggr_filter_id</code>. Note that
 only the built-in filter types of <code class="literal">TFILTER_SUM</code>, 
<code class="literal">TFILTER_MIN</code>, <code class="literal">TFILTER_MAX</code>, 
<code class="literal">TFILTER_AVG</code>, and <code class="literal">TFILTER_ARRAY_CONCAT</code> 
are supported. By default, performance data from each Rank is concatenated,
and <code class="varname">results</code> contains every recorded data instance for
each Rank. If the summary aggregation filters are used, 
<code class="varname">results</code> will contain a single associated pair. The
Rank for this pair is equal to <code class="literal">-1*(number of aggregated ranks)</code>,
and the vector contains one or more aggregated instances. </p></blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">Stream::print_PerformanceData</b>(</code></td><td><var class="pdparam">metric</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">context</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>perfdata_metric_t </code> </td><td><code><var class="pdparam">metric</var>;</code></td></tr><tr><td><code>perfdata_context_t </code> </td><td><code><var class="pdparam">context</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote"><code class="function">Stream::print_PerformanceData</code> prints recorded
performance data of the specified <code class="varname">metric</code> type for the
given <code class="varname">context</code>. At each Rank, the data is printed to the
MRNet log files and then discarded.
</blockquote></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sect:packet_api"></a>Class Packet</h2></div></div></div><p>
A Packet encapsulates a chunk of formatted data sent on a Stream. 
Packets are created using a format string (e.g., 
<code class="literal">"%s %d"</code> describes a null-terminated string followed
by a 32-bit integer, and the Packet is said to contain 2 data elements).
MRNet front-end and back-end processes do not create instances of Packet; 
instead they are automatically produced from the 
formatted data passed to <code class="function">Stream::send</code>.
<a class="xref" href="#format_strings" title="Appendix A. MRNet Format Strings">Appendix A, <i>MRNet Format Strings</i></a> contains the full listing of data types
that can be sent in a Packet.
</p><p>
When receiving a Packet via <code class="function">Stream::recv</code> or 
<code class="function">Network::recv</code>,
the Packet instance is stored within a PacketPtr object. PacketPtr is a class
based on the Boost library shared_ptr class, and helps with memory management 
of Packets. A PacketPtr can be assumed to be equivalent to "Packet *", and 
all operations on Packets require use of PacketPtr.
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">int <b class="fsfunc">Packet::get_Tag</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns the integer tag associated with the Packet.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">unsigned short <b class="fsfunc">Packet::get_StreamId</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns the stream id associated with the Packet.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">const char * <b class="fsfunc">Packet::get_FormatString</b>(</code></td><td><code>)</code>;</td><td> </td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method returns the character string specifying the data format of the Packet.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">Packet::unpack</b>(</code></td><td><var class="pdparam">format_string</var>, </td><td> </td></tr><tr><td> </td><td>...<code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>const char * </code> </td><td><code><var class="pdparam">format_string</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method extracts data contained within a Packet according to the 
<code class="varname">format_string</code>, which must match that of the Packet.
The function arguments following <code class="varname">format_string</code> should
be pointers to the appropriate types of each data item. For string and
array data types, new memory buffers to hold the data will be allocated 
using <code class="function">malloc()</code>, and it is the user's responsibility
to <code class="function">free()</code> these strings and arrays.
</blockquote></div></div><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">Packet::set_DestroyData</b>(</code></td><td><var class="pdparam">destroy</var>, </td><td> </td></tr><tr><td> </td><td>...<code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>bool </code> </td><td><code><var class="pdparam">destroy</var>;</code></td></tr></table><div class="blockquote"><blockquote class="blockquote">
This method can be used to tell MRNet whether or not to deallocate the
string and array data members of a Packet. If <code class="varname">destroy</code> is true,
string and array data members will be deallocated using <code class="function">free()</code>
when the Packet destructor is executed. Note this assumes they were allocated 
using <code class="function">malloc()</code>. The default behavior for user-generated
Packets is not to deallocate (false). 
Turning on deallocation is useful in filter code that must allocate strings or
arrays for output Packets, which cannot be freed before the filter function returns.
</blockquote></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="mrnet_topology_configuration"></a>Chapter 6. MRNET Process-tree
Topologies</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id2531347">Topology File Format</a></span></dt><dt><span class="sect1"><a href="#id2532016">Topology File Generator</a></span></dt></dl></div><p>
MRNet allows a tool to specify a node allocation and process connectivity
tailored to its computation and communication requirements and to the system
where the tool will run. Choosing an appropriate MRNet configuration can be
difficult due to the complexity of the tool's own activity and its
interaction with the system. This section describes how users define
their own process topologies, and the <span class="command"><strong>mrnet_topgen</strong></span> utility
provided by MRNet to facilitate the process.
</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2531347"></a>Topology File Format</h2></div></div></div><p>
The first parameter to the <code class="function">Network::Network()</code>
front-end constructor is the name of an MRNet topology file. This file defines the
topological layout of the front-end, internal nodes, and back-end MRNet processes. 
In the syntax of the topology file, the
<code class="varname">hostname:id</code> tuple represents a process with a MRNet instance
<code class="varname">id</code> running on <code class="varname">hostname</code>. It is important
to note that the <code class="varname">id</code> is of symbolic value only and does not
reflect a port or process number associated with the system. A line in the
topology file is always of the form:
</p><pre class="synopsis">
hostname1:0 =&gt; hostname1:1 hostname1:2 ;
</pre><p>
meaning a process on <code class="varname">hostname1</code> with MRNet id 0
has two children, with MRNet ids 1 and 2, running on the
same host. MRNet will parse the topology file without error if the file
properly defines a tree in the mathematical sense (i.e. a tree must have
a single root, no cycles, full connection, and no node can be its own
descendant).
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
A single topology specification line may span multiple physical lines to
improve readability. For example:
<pre class="synopsis">
   hostname1:0 =&gt; 
                  hostname1:1 
                  hostname1:2 
                  ;
</pre></div><p>
</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>
The hostname associated with the root of the topology must match the host
where the front-end process is run.
</div><p>
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2532016"></a>Topology File Generator</h2></div></div></div><p>
When the MRNet test programs are built, a topology generator program,
<code class="filename">$MRNET_ROOT/bin/$MRNET_ARCH/mrnet_topgen</code>, will also
be created. The usage of this program is:
</p><pre class="synopsis">
mrnet_topgen [OPTIONS] TOPOLOGY_SPEC [INFILE] [OUTFILE]

Create a MRNet topology from the machines listed in [INFILE],
or standard input, and writes output to [OUTFILE], or standard output.

The format of the input machine list is one machine specification per line,
where each specification is of the form "host[:num-processors]". Note that
the first machine listed should be the host where the front-end should be run.

         OPTIONS:

         -m max-host-procs, --maxprocs=max-host-procs
                 Specify the maximum number of processes to place on any machine,
                 in which case the number of processes allocated to a machine will be
                 the minimum of its processor count and "max-host-procs".

         TOPOLOGIES:

         -b topology, --balanced=topology
                 Create a balanced tree using "topology" specification. The specification
                 is in the format F^D, where F is the fan-out (or out-degree) and D is the
                 tree depth. The number of tree leaves (or back-ends) will be F^D.
                 An alternative specification is FxFxF, where the fan-out at each level
                 is specified explicitly and can differ between levels.

                 Example: "16^3" is a tree of depth 3 with fan-out 16, with 4096 leaves.
                 Example: "2x4x8" is a tree of depth 3 with 64 leaves.

         -k topology, --knomial=topology
                 Create a k-nomial tree using "topology" specification. The specification
                 is in the format K@N, where K is the k-factor (&#8805;2) and N is the total
                 number of tree nodes. The number of tree leaves (or back-ends) will be
                 (N/K)*(K-1).

                 Example: "2@128" is a binomial tree of 128 nodes, with 64 leaves.
                 Example: "3@27" is a trinomial tree of 27 nodes, with 18 leaves.

         -o topology, --other=topology
                 Create a generic tree using "topology" specification. The specification
                 for this option is (the agreeably complicated) N:N,N,N:... where N is
                 the number of children, ',' distinguishes nodes on the same level,
                 and ':' separates the tree into levels.

                 Example: "2:8,4" is a tree where the root has 2 children,
                          the 1st child has 8 children, and the
                          2nd child has 4 children.


</pre><p>
</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="adding_filters"></a>Chapter 7. Adding New Filters</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#id2532118">Defining an MRNet Filter</a></span></dt><dt><span class="sect1"><a href="#id2532396">Creating and Using MRNet Filter Shared Object Files</a></span></dt></dl></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2532118"></a>Defining an MRNet Filter</h2></div></div></div><p>
A filter function has the following signature
</p><div class="funcsynopsis"><table border="0" summary="Function synopsis" cellspacing="0" cellpadding="0" style="padding-bottom: 1em"><tr><td><code class="funcdef">void <b class="fsfunc">filter_name</b>(</code></td><td><var class="pdparam">packets_in</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">packets_out</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">packets_out_reverse</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">local_storage</var>, </td><td> </td></tr><tr><td> </td><td><var class="pdparam">config_params</var><code>)</code>;</td><td> </td></tr></table><table border="0" summary="Function argument synopsis" cellspacing="0" cellpadding="0"><tr><td><code>std::vector&lt; PacketPtr &gt; &amp; </code> </td><td><code><var class="pdparam">packets_in</var>;</code></td></tr><tr><td><code>std::vector&lt; PacketPtr &gt; &amp; </code> </td><td><code><var class="pdparam">packets_out</var>;</code></td></tr><tr><td><code>std::vector&lt; PacketPtr &gt; &amp; </code> </td><td><code><var class="pdparam">packets_out_reverse</var>;</code></td></tr><tr><td><code>void ** </code> </td><td><code><var class="pdparam">local_storage</var>;</code></td></tr><tr><td><code>PacketPtr &amp; </code> </td><td><code><var class="pdparam">config_params</var>;</code></td></tr></table></div><p>
<code class="varname">packets_in</code> is a reference to a vector of Packets serving
as input to the filter function. <code class="varname">packets_out</code> is a
reference to a vector into which output Packets should be placed. In the
rare case where Packets need to be sent in the reverse direction on the
Stream, <code class="varname">packets_out_reverse</code> should be used instead of 
<code class="varname">packets_out</code>.
<code class="varname">local_storage</code> may be used to define and maintain
state specific to a filter instance. Finally, <code class="varname">config_params</code>
is a reference to a PacketPtr containing the current configuration settings
for the filter instance, as can be set using <code class="function">Stream::set_FilterParameters</code>. 
</p><p>
For each filter function defined in a shared object file, there must be a
<span class="type">const char *</span> symbol named
by the string formed by the concatenation of the filter function name and
the suffix <code class="literal">"_format_string"</code>. For instance, if the filter function is named
<code class="varname">my_filter_func</code>, the shared object must define a symbol
<span class="type">const char *</span><code class="varname">my_filter_func_format_string</code>.
The value of this string will be the MRNet format string describing the
format of data that the filter can operate on. A value of <code class="literal">""</code>
 denotes that the filter can operate on data of arbitrary value.
</p></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2532396"></a>Creating and Using MRNet Filter Shared Object Files</h2></div></div></div><p>
This topic currently pertains to use with the GNU C++ compiler only.
</p><p>
Since we use the C facility <code class="function">dlopen()</code> to dynamically
load new filter functions, all C++ symbols must be exported. That is, 
the symbol definitions must fall with the statements

</p><pre class="programlisting">
extern "C" {
</pre><p>
and 
</p><pre class="programlisting">
}
</pre><p>

The file that contains the filter functions and format strings may be
compiled with the GNU compiler options <code class="literal">"-fPIC -shared -rdynamic"
</code> to produce a valid shared object.
</p><p>
Front-end and back-end programs that will dynamically load filters must be built
with compiler options that notify the linker to export global symbols 
(for GNU compilers, you can use <code class="literal">"-Wl,-E"</code>).
</p></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="format_strings"></a>Appendix A. MRNet Format Strings</h2></div></div></div><p>
After the % character that introduces a conversion, there
may be a number of flag characters. <span class="emphasis"><em>u</em></span>,
<span class="emphasis"><em>h</em></span>, <span class="emphasis"><em>l</em></span>, and <span class="emphasis"><em>a</em></span>
are special modifiers meaning unsigned, short, long and array, respectivley.
The full set of conversions are:
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td>c</td><td> signed 8-bit character</td></tr><tr><td>uc</td><td> unsigned 8-bit character</td></tr><tr><td>ac</td><td> array of signed 8-bit characters</td></tr><tr><td>auc</td><td> array of unsigned 8-bit characters</td></tr><tr><td>hd</td><td> signed 16-bit decimal integer</td></tr><tr><td>uhd</td><td> unsigned 16-bit decimal integer</td></tr><tr><td>ahd</td><td> array of signed 16-bit decimal integers</td></tr><tr><td>auhd</td><td> array of unsigned 16-bit decimal integers</td></tr><tr><td>d</td><td> signed 32-bit decimal integer</td></tr><tr><td>ud</td><td> unsigned 32-bit decimal integer</td></tr><tr><td>ad</td><td> array of signed 32-bit decimal integers</td></tr><tr><td>aud</td><td> array of unsigned 32-bit decimal integers</td></tr><tr><td>ld</td><td> signed 64-bit decimal integer</td></tr><tr><td>uld</td><td> unsigned 64-bit decimal integer</td></tr><tr><td>ald</td><td> array of signed 64-bit decimal integers</td></tr><tr><td>auld</td><td> array of unsigned 64-bit decimal integers</td></tr><tr><td>f</td><td> 32-bit floating-point number</td></tr><tr><td>af</td><td> array of 32-bit floating-point numbers</td></tr><tr><td>lf</td><td> 64-bit floating-point number</td></tr><tr><td>alf</td><td> array of 64-bit floating-point numbers</td></tr><tr><td>s</td><td> null-terminated character string.</td></tr><tr><td>as</td><td> array of null-terminated character strings.</td></tr></tbody></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3>All array format specifiers, <code class="literal">"a*"</code>, require an extra <span class="emphasis"><em>implicit</em></span> length parameter of type <span class="type">unsigned int</span> to be specified. E.g., <code class="literal">send("%d %af", integer_val, float_array_pointer, float_array_length)</code></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="perf_data"></a>Appendix B. MRNet Stream Performance Data</h2></div></div></div><p>The primary abstraction for communication and data processing
within MRNet is the stream, so performance metrics and contexts are
associated with actions on a particular stream.</p><p>All data is recorded as instances of a <code class="literal">perf_data_t</code>, which
is simply a union type that can hold a 64-bit signed integer, a 64-bit unsigned 
integer, or a double precision float. As shown below, the data values can be
accessed using the <code class="literal">i</code>, <code class="literal">u</code>, or <code class="literal">d</code>
union fields.</p><code class="literal">"typedef union { int64_t i; uint64_t u; double d; } perfdata_t;"</code><p>
Metrics define the type of performance data to record. The supported metric types are:
</p><div class="itemizedlist"><ul type="disc"><li><code class="literal">PERFDATA_MET_NUM_BYTES</code>: count of data bytes 
(<span class="type">uint64_t</span>)</li><li><code class="literal">PERFDATA_MET_NUM_PKTS</code>: count of data packets 
(<span class="type">uint64_t</span>)</li><li><code class="literal">PERFDATA_MET_ELAPSED_SEC</code>: elapsed seconds 
(<span class="type">double</span>)</li><li><code class="literal">PERFDATA_MET_CPU_USR_PCT</code>: percent CPU utilization by user 
(<span class="type">double</span>)</li><li><code class="literal">PERFDATA_MET_CPU_USR_PCT</code>: percent CPU utilization by system 
(<span class="type">double</span>)</li><li><code class="literal">PERFDATA_MET_MEM_VIRT_KB</code>: virtual memory footprint in KB 
(<span class="type">double</span>)</li><li><code class="literal">PERFDATA_MET_MEM_PHYS_KB</code>: physical memory footprint in KB 
(<span class="type">double</span>)</li></ul></div><p>
</p><p>
Contexts specify when to record data. The supported contexts are:
</p><div class="itemizedlist"><ul type="disc"><li><code class="literal">PERFDATA_CTX_SEND</code>: when data is sent</li><li><code class="literal">PERFDATA_CTX_RECV</code>: when data is received</li><li><code class="literal">PERFDATA_CTX_FILT_IN</code>: before executing transformation filter</li><li><code class="literal">PERFDATA_CTX_FILT_OUT</code>: after executing transformation filter</li><li><code class="literal">PERFDATA_CTX_NONE</code>: when data is collected</li></ul></div><p>
</p><p>
The following table shows which metrics are valid for a given context.
When a metric is valid for only <code class="literal">CTX_FILT_OUT</code>, the 
metric is actually recorded through a combination of measurements at 
<code class="literal">CTX_FILT_IN</code> and <code class="literal">CTX_FILT_OUT</code>.
When a metric is valid for only <code class="literal">CTX_NONE</code>, the 
data is only recorded at the time it is collected. 
</p><div class="table"><a name="id2533448"></a><p class="title"><b>Table B.1. Metric-Context Compatibility Matrix</b></p><div class="table-contents"><table summary="Metric-Context Compatibility Matrix" border="1"><colgroup><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center"> </th><th align="center">CTX_SEND</th><th align="center">CTX_RECV</th><th align="center">CTX_FILT_IN</th><th align="center">CTX_FILT_OUT</th><th align="center">CTX_NONE</th></tr></thead><tbody><tr><td align="center">MET_NUM_BYTES</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td></tr><tr><td align="center">MET_NUM_PKTS</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td></tr><tr><td align="center">MET_ELAPSED_SEC</td><td align="center">no</td><td align="center">no</td><td align="center">no</td><td align="center">yes</td><td align="center">no</td></tr><tr><td align="center">MET_CPU_USR_PCT</td><td align="center">no</td><td align="center">no</td><td align="center">no</td><td align="center">yes</td><td align="center">no</td></tr><tr><td align="center">MET_CPU_SYS_PCT</td><td align="center">no</td><td align="center">no</td><td align="center">no</td><td align="center">yes</td><td align="center">no</td></tr><tr><td align="center">MET_MEM_VIRT_KB</td><td align="center">no</td><td align="center">no</td><td align="center">no</td><td align="center">no</td><td align="center">yes</td></tr><tr><td align="center">MET_MEM_PHYS_KB</td><td align="center">no</td><td align="center">no</td><td align="center">no</td><td align="center">no</td><td align="center">yes</td></tr></tbody></table></div></div><br class="table-break"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><code class="literal">MET_CPU_USR_PCT</code>, <code class="literal">MET_CPU_SYS_PCT</code>, 
<code class="literal">MET_MEM_VIRT_KB</code>, and <code class="literal">MET_MEM_PHYS_KB</code> are
currently only supported for Linux.</div><p>An example MRNet application that makes use of the Stream performance data
collection facilities is provided in <code class="filename">$MRNET_ROOT/Examples/PerformanceData</code>.
</p></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="example"></a>Appendix C. A Complete MRNet Example: Integer Addition</h2></div></div></div><p>The source code for the example contained in this appendix can
be found in <code class="filename">$MRNET_ROOT/Examples/IntegerAddition</code>.
All examples can be built by typing 'make' from within the 
<code class="filename">$MRNET_ROOT/Examples</code> directory.
</p><div class="example"><a name="id2533332"></a><p class="title"><b>Example C.1. A Complete MRNet Front-End</b></p><div class="example-contents"><pre class="programlisting">
#include "mrnet/MRNet.h"
#include "IntegerAddition.h"

using namespace MRN;

int main(int argc, char **argv)
{
    int send_val=32, recv_val=0;
    int tag, retval;
    PacketPtr p;

    if( argc != 4 ){
        fprintf(stderr, "Usage: %s topology_file backend_exe so_file\n", argv[0]);
        exit(-1);
    }
    const char * topology_file = argv[1];
    const char * backend_exe = argv[2];
    const char * so_file = argv[3];
    const char * dummy_argv=NULL;

    // This Network() cnstr instantiates the MRNet internal nodes, according to the
    // organization in "topology_file," and the application back-end with any
    // specified cmd line args
    Network * network = new Network( topology_file, backend_exe, &amp;dummy_argv  );

    // Make sure path to "so_file" is in LD_LIBRARY_PATH
    int filter_id = network-&gt;load_FilterFunc( so_file, "IntegerAdd" );
    if( filter_id == -1 ){
        fprintf( stderr, "Network::load_FilterFunc() failure\n");
        delete network;
        return -1;
    }

    // A Broadcast communicator contains all the back-ends
    Communicator * comm_BC = network-&gt;get_BroadcastCommunicator( );

    // Create a stream that will use the Integer_Add filter for aggregation
    Stream * stream = network-&gt;new_Stream( comm_BC, filter_id,
                                            SFILTER_WAITFORALL);

    int num_backends = comm_BC-&gt;get_EndPoints().size();

    tag = PROT_SUM;
    unsigned int num_iters=5;
    // Broadcast a control message to back-ends to send us "num_iters"
    // waves of integers
    if( stream-&gt;send( tag, "%d %d", send_val, num_iters ) == -1 ){
        fprintf( stderr, "stream::send() failure\n");
        return -1;
    }
    if( stream-&gt;flush( ) == -1 ){
        fprintf( stderr, "stream::flush() failure\n");
        return -1;
    }

    // We expect "num_iters" aggregated responses from all back-ends
    for( unsigned int i=0; i&lt;num_iters; i++ ){
        retval = stream-&gt;recv(&amp;tag, p);
        assert( retval != 0 ); //shouldn't be 0, either error or block till data
        if( retval == -1){
            //recv error
            return -1;
        }

        if( p-&gt;unpack( "%d", &amp;recv_val ) == -1 ){
            fprintf( stderr, "stream::unpack() failure\n");
            return -1;
        }

        if( recv_val != num_backends * i * send_val ){
            fprintf(stderr, "Iteration %d: Success! recv_val(%d) != %d*%d*%d=%d (send_val*i*num_backends)\n",
                    i, recv_val, send_val, i, num_backends, send_val*i*num_backends );
        }
        else{
            fprintf(stderr, "Iteration %d: Success! recv_val(%d) == %d*%d*%d=%d (send_val*i*num_backends)\n",
                    i, recv_val, send_val, i, num_backends, send_val*i*num_backends );
        }
    }

    if(stream-&gt;send(PROT_EXIT, "") == -1){
        fprintf( stderr, "stream::send(exit) failure\n");
        return -1;
    }
    if(stream-&gt;flush() == -1){
        fprintf( stderr, "stream::flush() failure\n");
        return -1;
    }

    // The Network destructor will cause all internal and leaf tree nodes to exit
    delete network;

    return 0;
}
</pre></div></div><br class="example-break"><div class="example"><a name="id2533247"></a><p class="title"><b>Example C.2. A Complete MRNet Back-End</b></p><div class="example-contents"><pre class="programlisting">
#include "mrnet/MRNet.h"
#include "IntegerAddition.h"

using namespace MRN;

int main(int argc, char **argv)
{
    Stream * stream=NULL;
    PacketPtr p;
    int tag=0, recv_val=0, num_iters=0;

    Network * network = new Network( argc, argv );

    do{
        if ( network-&gt;recv(&amp;tag, p, &amp;stream) != 1){
            fprintf(stderr, "stream::recv() failure\n");
            return -1;
        }

        switch(tag){
        case PROT_SUM:
            p-&gt;unpack( "%d %d", &amp;recv_val, &amp;num_iters );

            // Send num_iters waves of integers
            for( unsigned int i=0; i&lt;num_iters; i++ ){
                if( stream-&gt;send(tag, "%d", recv_val*i) == -1 ){
                    fprintf(stderr, "stream::send(%%d) failure\n");
                    return -1;
                }
                if( stream-&gt;flush( ) == -1 ){
                    fprintf(stderr, "stream::flush() failure\n");
                    return -1;
                }
            }
            break;

        case PROT_EXIT:
            fprintf( stdout, "Processing PROT_EXIT ...\n");
            break;

        default:
            fprintf(stdout, "Unknown Protocol: %d\n", tag);
            break;
        }
    } while ( tag != PROT_EXIT );

    return 0;
}
</pre></div></div><br class="example-break"><div class="example"><a name="id2533280"></a><p class="title"><b>Example C.3. An MRNet Filter: Integer Addition</b></p><div class="example-contents"><pre class="programlisting">
extern "C" {

//Must Declare the format of data expected by the filter
const char * IntegerAdd_format_string = "%d"; 
void IntegerAdd( std::vector&lt; PacketPtr &gt; &amp; packets_in,
                 std::vector&lt; PacketPtr &gt; &amp; packets_out,
                 std::vector&lt; PacketPtr &gt; &amp; /* packets_out_reverse */,
                 void ** /* client data */,
		 PacketPtr &amp; /* params */ )
{
    int sum = 0;
    
    for( unsigned int i = 0; i &lt; packets_in.size( ); i++ ) {
        PacketPtr cur_packet = packets_in[i];
	int val;
	cur_packet-&gt;unpack("%d", &amp;val);
        sum += val;
    }
    
    PacketPtr new_packet ( new Packet(packets_in[0]-&gt;get_StreamId(),
                                      packets_in[0]-&gt;get_Tag(), "%d", sum ) );
    packets_out.push_back( new_packet );
}

} /* extern "C" */
</pre></div></div><br class="example-break"><div class="example"><a name="id2534344"></a><p class="title"><b>Example C.4. An MRNet Topology File</b></p><div class="example-contents"><pre class="programlisting">
nutmeg:0 =&gt; c01:0 c02:0 c03:0 c04:0 ;

c03:0 =&gt; c05:0 ;

c04:0 =&gt; c06:0 c07:0 c08:0 c09:0 ;

c08:0 =&gt; c10:0 ;

c09:0 =&gt; c11:0 ;

#       nutmeg
#          |
#          |
#       -------
#       /|   |\
#      / |   | \
#     /  |   |  \
#    /   |   |   \
#  c01  c02  c03  c04
#             |    |
#            c05   |
#               -------
#              / |   | \
#             /  |   |  \
#            /   |   |   \
#          c06  c07 c08  c09
#                    |    |
#                   c10  c11 
</pre></div></div><br class="example-break"></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="env_vars"></a>Appendix D. Environment Variables</h2></div></div></div><p>
A number of environment variables are available to control the
functionality of MRNet.
</p><div class="informaltable"><table border="1"><colgroup><col><col></colgroup><tbody><tr><td>XPLAT_RSH</td><td>Set this variable to the name of the remote shell program to use for
remote process execution. Default is 'ssh'.</td></tr><tr><td>XPLAT_REMCMD</td><td>If it is necessary to run the remote shell program (XPLAT_RSH) with a 
utility such as <code class="filename">runauth</code> to non-interactively authenticate 
the unattended remote process, that command may be specified using this variable.</td></tr><tr><td>XPLAT_RESOLVE_HOSTS</td><td>Tell XPlat to perform DNS resolution of hostnames and IP addresses by
setting the variable to '1'. Default is '1'.</td></tr><tr><td>XPLAT_RESOLVE_CANONICAL</td><td>When XPLAT_RESOLVE_HOSTS is '1', setting this variable to '1' will
tell XPlat to try to resolve all hostnames to their canonical DNS format. Default
is '0'.</td></tr><tr><td>MRNET_OUTPUT_LEVEL</td><td>Set the debug output level (valid values are 1-5, default is 1). Level 1 will
only log warning/error messages, level 3 provides fairly detailed function execution logging,
and level 5 will produce every log message that MRNet generates.</td></tr><tr><td>MRNET_DEBUG_LOG_DIRECTORY</td><td>Specify the absolute path to the directory to store MRNet log files generated by
increasing MRNET_OUTPUT_LEVEL. If not set, the first existing directory from the following
list is used:<div class="itemizedlist"><ul type="disc"><li><code class="filename">$HOME/mrnet-log</code></li><li><code class="filename">$HOME</code></li><li><code class="filename">/tmp</code></li></ul></div></td></tr><tr><td>MRN_COMM_PATH</td><td>If <code class="filename">mrnet_commnode</code> is not in your path by default, 
you can specify the full path using this variable.</td></tr></tbody></table></div></div></div></body></html>

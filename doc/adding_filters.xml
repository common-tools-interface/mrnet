<chapter id="adding_filters"><title>Adding New Filters</title>

<sect1><title>Defining an MRNet Filter</title>

<para>
A filter function has the following signature:
<funcsynopsis>
<funcprototype>
  <funcdef>void <function>filter_name</function></funcdef>
    <paramdef>std::vector&lt; PacketPtr &gt; &amp; <parameter>packets_in</parameter></paramdef>
    <paramdef>std::vector&lt; PacketPtr &gt; &amp; <parameter>packets_out</parameter></paramdef>
    <paramdef>std::vector&lt; PacketPtr &gt; &amp; <parameter>packets_out_reverse</parameter></paramdef>
    <paramdef>void ** <parameter>filter_state</parameter></paramdef>
    <paramdef>PacketPtr &amp; <parameter>config_params</parameter></paramdef>
</funcprototype>
</funcsynopsis>
<varname>packets_in</varname> is a reference to a vector of Packets serving
as input to the filter function. <varname>packets_out</varname> is a
reference to a vector into which output Packets should be placed. In the
rare case where Packets need to be sent in the reverse direction on the
Stream, <varname>packets_out_reverse</varname> should be used instead of 
<varname>packets_out</varname>.
<varname>filter_state</varname> may be used to define and maintain
state specific to a filter instance. Finally, <varname>config_params</varname>
is a reference to a PacketPtr containing the current configuration settings
for the filter instance, as can be set using <function>Stream::set_FilterParameters</function>. 
</para>

<para>
For each filter function defined in a shared object file, there must be a
<type>const char *</type> symbol named
by the string formed by the concatenation of the filter function name and
the suffix <literal>"_format_string"</literal>. For instance, if the filter function is named
<varname>my_filter_func</varname>, the shared object must define a symbol
<type>const char *</type><varname>my_filter_func_format_string</varname>.
The value of this string will be the MRNet format string describing the
format of data that the filter can operate on. A value of <literal>""</literal>
 denotes that the filter can operate on data of arbitrary value.
</para>

</sect1>

<sect1><title>Fault-tolerant MRNet Filters</title>
<para>
MRNet automatically recovers from failures of internal tree processes (i.e., those
processes that are not the front-end (root) or back-ends (leaves)). As part of the
recovery, MRNet will extract filter state from the children of a failed process
and pass that state as input to each child's newly chosen parent. If you have a filter
that maintains persistent state using <varname>filter_state</varname>, you can
provide an additional function within the shared object for your filter that
MRNet may use to extract the state. The name of this extraction function should be
the same as the filter name with the suffix <literal>"_get_state"</literal> appended. 
For instance, if the filter function is named <varname>my_filter_func</varname>, 
the extraction function should be named <varname>my_filter_func_get_state</varname>.
</para>

<para> A filter state extraction function has the following signature:
<funcsynopsis>
<funcprototype>
  <funcdef>PacketPtr <function>filter_name_get_state</function></funcdef>
    <paramdef>void ** <parameter>filter_state</parameter></paramdef>
    <paramdef>int <parameter>stream_id</parameter></paramdef>
</funcprototype>
</funcsynopsis>
<varname>filter_state</varname> is a pointer to the state defined by the
filter for the given Stream identified by <varname>stream_id</varname>. This
function should extract the necessary state and return a Packet that can
be passed as input to the filter function. Since the Packet will be processed
as a normal input Packet for the filter, it's format must match that expected
by the filter. A fault-tolerant filter example is provided in 
<filename>$MRNET_ROOT/Examples/FaultRecovery</filename>.
</para>
</sect1>

<sect1><title>Creating and Using MRNet Filter Shared Object Files</title>
<para>
This topic currently pertains to use with the GNU C++ compiler only.
</para>

<para>
Since we use the C facility <function>dlopen()</function> to dynamically
load new filter functions, all C++ symbols must be exported. That is, 
the symbol definitions must fall with the statements

<programlisting>
extern "C" {
</programlisting>
and 
<programlisting>
}
</programlisting>

The file that contains the filter functions and format strings may be
compiled with the GNU compiler options <literal>"-fPIC -shared -rdynamic"
</literal> to produce a valid shared object.
</para>

<para>
Front-end and back-end programs that will dynamically load filters must be built
with compiler options that notify the linker to export global symbols 
(for GNU compilers, you can use <literal>"-Wl,-E"</literal>).
</para>

</sect1>

</chapter>
